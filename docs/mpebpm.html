<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-05-08 Fri 01:05 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Massively Parallel Empirical Bayes Poisson Means</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="bootstrap.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="htmlize.css"/>
<link rel="stylesheet" type="text/css" href="main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Massively Parallel Empirical Bayes Poisson Means</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#results">Results</a>
<ul>
<li><a href="#accuracy">Accuracy of parameter estimation</a></li>
<li><a href="#gof">Goodness of fit</a></li>
<li><a href="#ipsc">Application to iPSCs</a></li>
<li><a href="#org1a9953a">Confounder correction in iPSC data</a></li>
<li><a href="#immune-census">Application to Census of Immune Cells</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org62be355" class="outline-2">
<h2 id="introduction"><a id="org62be355"></a>Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
The <i>Empirical Bayes Poisson Means</i> (EBPM) problem is \( 
  \DeclareMathOperator\Gam{Gamma}
  \DeclareMathOperator\Poi{Poisson}
  \DeclareMathOperator\argmin{arg min}
  \newcommand\mf{\mathbf{F}} 
  \newcommand\ml{\mathbf{L}}
  \newcommand\mx{\mathbf{X}}
  \newcommand\vl{\mathbf{l}}
  \newcommand\vx{\mathbf{x}}
  \)
</p>

\begin{align*}
  x_i \mid s_i, \lambda_i &\sim \Poi(s_i \lambda_i)\\
  \lambda_i &\sim g(\cdot) \in \mathcal{G},
\end{align*}

<p>
where the (primary) inference goal is to estimate \(g\) by maximizing the
likelihood. In our prior work
(<a href="https://dx.doi.org/10.1371/journal.pgen.1008045">Sarkar et al. 2019</a>), we
used this approach to estimate the mean and variance of gene expression from
scRNA-seq data collected on a homogeneous sample of cells from each of a
number of donor individuals, where we assumed \(\mathcal{G}\) was the family
of point-Gamma distributions. In total, we solved 537,678 EBPM problems in
parallel by formulating them as a single factor model
</p>

\begin{align*}
  x_{ij} \mid x_{i+}, \lambda_{ij} &\sim \Poi(x_{i+} \lambda_{ij})\\
  \lambda_{ij} \mid \mu_{ij}, \phi_{ij}, \pi_{ij} &\sim \pi_{ij} \delta_0(\cdot) + (1 - \pi_{ij}) \Gam(\phi_{ij}^{-1}, \mu_{ij}^{-1} \phi_{ij}^{-1})\\
  \ln \mu_{ij} &= (\ml \mf_\mu')_{ij}\\
  \ln \phi_{ij} &= (\ml \mf_\phi')_{ij}\\
  \operatorname{logit} \pi_{ij} &= (\ml \mf_\pi')_{ij},
\end{align*}

<p>
where 
</p>

<ul class="org-ul">
<li>\(x_{ij}\) is the number of molecules of gene \(j = 1, \ldots, p\) observed
in cell \(i = 1, \ldots, n\)</li>
<li>\(x_{i+} \triangleq \sum_j x_{ij}\) is the total number of molecules
observed in sample \(i\)</li>
<li>cells are taken from \(m\) donor individuals, \(\ml\) is \(n \times m\),
and each \(\mf_{(\cdot)}\) is \(p \times m\)</li>
<li>assignments of cells to donors (loadings) \(l_{ik} \in \{0, 1\}, k = 1,
    \ldots, m\) are known and fixed.</li>
</ul>

<p>
We previously implemented maximum likelihood inference of this model via
batch gradient descent in the Python package
<a href="https://www.github.com/aksarkar/scqtl.git">scqtl</a>. We have now developed a
new Python package <a href="https://www.github.com/aksarkar/mpebpm.git">mpebpm</a>,
which scales to much larger data sets. The key improvements are optimization
using minibatch gradient descent and support for sparse matrices. Here, we
evaluate the method on simulations and large biological data sets.
</p>
</div>
</div>

<div id="outline-container-org9626900" class="outline-2">
<h2 id="setup"><a id="org9626900"></a>Setup</h2>
<div class="outline-text-2" id="text-setup">
<pre class="example">
Submitted batch job 1033114

</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> anndata
<span class="org-keyword">import</span> mpebpm
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> scipy.sparse <span class="org-keyword">as</span> ss
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> scipy.stats <span class="org-keyword">as</span> st
<span class="org-keyword">import</span> scmodes
<span class="org-keyword">import</span> scqtl
<span class="org-keyword">import</span> time
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> gzip
<span class="org-keyword">import</span> rpy2.robjects.pandas2ri
<span class="org-keyword">import</span> rpy2.robjects.packages
<span class="org-keyword">import</span> tabix

rpy2.robjects.pandas2ri.activate()
<span class="org-variable-name">susie</span> = rpy2.robjects.packages.importr(<span class="org-string">'susieR'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
%config <span class="org-variable-name">InlineBackend.figure_formats</span> = <span class="org-builtin">set</span>([<span class="org-string">'retina'</span>])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'figure.facecolor'</span>] = <span class="org-string">'w'</span>
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'font.family'</span>] = <span class="org-string">'Nimbus Sans'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge80a058" class="outline-2">
<h2 id="results"><a id="orge80a058"></a>Results</h2>
<div class="outline-text-2" id="text-results">
</div>
<div id="outline-container-orgd051fd5" class="outline-3">
<h3 id="accuracy"><a id="orgd051fd5"></a>Accuracy of parameter estimation</h3>
<div class="outline-text-3" id="text-accuracy">
<p>
We previously evaluated <code>scqtl</code>
<a href="https://jdblischak.github.io/singlecell-qtl/zinb.html#orgca44e7f">by
simulating data from the model</a>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">def</span> <span class="org-function-name">evaluate</span>(num_samples, num_mols, num_trials=10, **kwargs):
  <span class="org-comment-delimiter"># </span><span class="org-comment">Important: generate all of the samples for each trial in one shot, and use</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">one-hot encoding to get separate estimates</span>
  <span class="org-variable-name">args</span> = [(num_samples * num_trials, num_mols, log_mu, log_phi, logodds, <span class="org-constant">None</span>, <span class="org-constant">None</span>, <span class="org-constant">None</span>)
          <span class="org-keyword">for</span> log_mu <span class="org-keyword">in</span> np.linspace(-12, -6, 7)
          <span class="org-keyword">for</span> log_phi <span class="org-keyword">in</span> np.linspace(-4, 0, 5)
          <span class="org-keyword">for</span> logodds <span class="org-keyword">in</span> np.linspace(-3, 3, 7)]
  <span class="org-variable-name">x</span> = np.concatenate([scqtl.simulation.simulate(*a)[0][:,:1] <span class="org-keyword">for</span> a <span class="org-keyword">in</span> args], axis=1)
  <span class="org-variable-name">x</span> = ss.csr_matrix(x)
  <span class="org-variable-name">s</span> = num_mols * np.ones((x.shape[0], 1))
  <span class="org-variable-name">onehot</span> = np.zeros((num_samples * num_trials, num_trials))
  onehot[np.arange(onehot.shape[0]), np.arange(onehot.shape[0]) // num_samples] = 1
  <span class="org-variable-name">onehot</span> = ss.csr_matrix(onehot)

  <span class="org-variable-name">log_mu</span>, <span class="org-variable-name">neg_log_phi</span>, <span class="org-variable-name">logodds</span>, <span class="org-variable-name">_</span> = mpebpm.ebpm_point_gamma(x, s=s, onehot=onehot, **kwargs)
  <span class="org-variable-name">result</span> = pd.DataFrame(
    [(a[0] // num_trials, <span class="org-builtin">int</span>(a[1]), <span class="org-builtin">int</span>(a[2]), <span class="org-builtin">int</span>(a[3]), <span class="org-builtin">int</span>(a[4]), a[-1], trial)
     <span class="org-keyword">for</span> a <span class="org-keyword">in</span> args
     <span class="org-keyword">for</span> trial <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_trials)],
    columns=[<span class="org-string">'num_samples'</span>, <span class="org-string">'num_mols'</span>, <span class="org-string">'log_mu'</span>, <span class="org-string">'log_phi'</span>, <span class="org-string">'logodds'</span>, <span class="org-string">'fold'</span>, <span class="org-string">'trial'</span>])
  <span class="org-variable-name">result</span>[<span class="org-string">'mean'</span>] = np.exp(result[<span class="org-string">'log_mu'</span>])
  <span class="org-variable-name">result</span>[<span class="org-string">'var'</span>] = (1 - sp.expit(result[<span class="org-string">'logodds'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu'</span>] + result[<span class="org-string">'log_phi'</span>]) + sp.expit(-result[<span class="org-string">'logodds'</span>]) * (1 - sp.expit(result[<span class="org-string">'logodds'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu'</span>])

  <span class="org-variable-name">result</span>[<span class="org-string">'log_mu_hat'</span>] = log_mu.ravel(order=<span class="org-string">'F'</span>)
  <span class="org-variable-name">result</span>[<span class="org-string">'log_phi_hat'</span>] = -neg_log_phi.ravel(order=<span class="org-string">'F'</span>)
  <span class="org-variable-name">result</span>[<span class="org-string">'logodds_hat'</span>] = logodds.ravel(order=<span class="org-string">'F'</span>)
  <span class="org-variable-name">result</span>[<span class="org-string">'mean_hat'</span>] = np.exp(result[<span class="org-string">'log_mu_hat'</span>])
  <span class="org-variable-name">result</span>[<span class="org-string">'var_hat'</span>] = (1 - sp.expit(result[<span class="org-string">'logodds_hat'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu_hat'</span>] + result[<span class="org-string">'log_phi_hat'</span>]) + sp.expit(-result[<span class="org-string">'logodds_hat'</span>]) * (1 - sp.expit(result[<span class="org-string">'logodds_hat'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu_hat'</span>])

  <span class="org-variable-name">diagnostic</span> = []
  <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(x.shape[1]):
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(onehot.shape[1]):
      <span class="org-variable-name">idx</span> = onehot.A[:,j].astype(<span class="org-builtin">bool</span>)
      diagnostic.append(scqtl.diagnostic.diagnostic_test(
        x.A[idx,i].reshape(-1, 1),
        log_mu[j,i],
        -neg_log_phi[j,i],
        -logodds[j,i],
        num_mols,
        np.ones((num_samples, 1))))
  <span class="org-variable-name">diagnostic</span> = np.array(diagnostic)
  <span class="org-variable-name">result</span>[<span class="org-string">'ks_d'</span>] = diagnostic[:,0]
  <span class="org-variable-name">result</span>[<span class="org-string">'ks_p'</span>] = diagnostic[:,1]
  <span class="org-keyword">return</span> result
</pre>
</div>

<p>
Run the simulation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = evaluate(num_samples=100, num_mols=<span class="org-builtin">int</span>(1e5), batch_size=32, max_epochs=200, verbose=<span class="org-constant">True</span>)
result.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-sim.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Read the results.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-sim.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
</pre>
</div>

<p>
Plot the estimated values against the ground truth values.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mu_pass</span> = result[<span class="org-string">'log_mu'</span>] &gt; -10
<span class="org-variable-name">pi_pass</span> = result[<span class="org-string">'logodds'</span>] &lt; 0

plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 3)
fig.set_size_inches(8, 5)

<span class="org-variable-name">subset</span> = result.loc[pi_pass]
ax[0, 0].scatter(subset[<span class="org-string">'log_mu'</span>], subset[<span class="org-string">'log_mu_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 0].set_xlim(-14, -5)
ax[0, 0].set_ylim(ax[0, 0].get_xlim())
ax[0, 0].plot(ax[0, 0].get_xlim(), ax[0, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 0].set_xlabel(<span class="org-string">'True $\ln(\mu)$'</span>)
ax[0, 0].set_ylabel(<span class="org-string">'Estimated $\ln(\mu)$'</span>)

ax[1, 0].set_xscale(<span class="org-string">'log'</span>)
ax[1, 0].set_yscale(<span class="org-string">'log'</span>)
ax[1, 0].scatter(subset[<span class="org-string">'mean'</span>], subset[<span class="org-string">'mean_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 0].set_xlim(1e-6, 1e-2)
ax[1, 0].set_ylim(ax[1, 0].get_xlim())
ax[1, 0].plot(ax[1, 0].get_xlim(), ax[1, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 0].set_xlabel(<span class="org-string">'True latent mean'</span>)
ax[1, 0].set_ylabel(<span class="org-string">'Estimated latent mean'</span>)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and.<span class="org-builtin">reduce</span>(np.vstack([mu_pass, pi_pass]))]
ax[0, 1].scatter(subset[<span class="org-string">'log_phi'</span>], subset[<span class="org-string">'log_phi_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 1].set_xlim(-5, 2)
ax[0, 1].set_ylim(ax[0, 1].get_xlim())
ax[0, 1].plot(ax[0, 1].get_xlim(), ax[0, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 1].set_xlabel(<span class="org-string">'True $\ln(\phi)$'</span>)
ax[0, 1].set_ylabel(<span class="org-string">'Estimated $\ln(\phi)$'</span>)

ax[1, 1].set_xscale(<span class="org-string">'log'</span>)
ax[1, 1].set_yscale(<span class="org-string">'log'</span>)
ax[1, 1].scatter(subset[<span class="org-string">'var'</span>], subset[<span class="org-string">'var_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 1].set_xlim(1e-9, 5e-5)
ax[1, 1].set_ylim(ax[1, 1].get_xlim())
ax[1, 1].plot(ax[1, 1].get_xlim(), ax[1, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 1].set_xlabel(<span class="org-string">'True latent variance'</span>)
ax[1, 1].set_ylabel(<span class="org-string">'Estimated latent variance'</span>)

<span class="org-variable-name">subset</span> = result.loc[pi_pass]
ax[0, 2].scatter(subset[<span class="org-string">'logodds'</span>], subset[<span class="org-string">'logodds_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 2].plot(ax[0, 2].get_xlim(), ax[0, 2].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 2].set_xlabel(<span class="org-string">'True $\mathrm{logit}(\pi)$'</span>)
ax[0, 2].set_ylabel(<span class="org-string">'Estimated $\mathrm{logit}(\pi)$'</span>)

ax[1, 2].set_axis_off()
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/sim-params.png" alt="sim-params.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org753cc61" class="outline-3">
<h3 id="gof"><a id="org753cc61"></a>Goodness of fit</h3>
<div class="outline-text-3" id="text-gof">
<p>
We previously developed a test for goodness of fit, based on the fact that
if \(x_{ij} \sim F_{ij}\), then \(F_{ij}(x_{ij}) \sim
   \operatorname{Uniform}(0, 1)\). We applied this test to the distributions
estimated from the simulated data sets. Plot the histogram of
goodness-of-fit \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result[<span class="org-string">'ks_p'</span>], bins=np.linspace(0, 1, 11), density=<span class="org-constant">True</span>, color=<span class="org-string">'0.7'</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlim(0, 1)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-sim-gof.png" alt="mpebpm-sim-gof.png">
</p>
</div>

<p>
Report the number (proportion) of simulation trials where the observed data
significantly depart from the estimated distribution (\(p < 0.05\) after
Bonferroni correction).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sig</span> = result.loc[result[<span class="org-string">'ks_p'</span>] &lt; 0.05 / result.shape[0]]
sig.shape[0], sig.shape[0] / result.shape[0]
</pre>
</div>

<pre class="example">
(0, 0.0)

</pre>
</div>
</div>

<div id="outline-container-org09c6f5e" class="outline-3">
<h3 id="ipsc"><a id="org09c6f5e"></a>Application to iPSCs</h3>
<div class="outline-text-3" id="text-ipsc">
<p>
We previously generated scRNA-seq of 5,597 cells from 54 donors
(<a href="https://dx.doi.org/10.1371/journal.pgen.1008045">Sarkar et
al. 2019</a>). Read the data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">x</span> = anndata.read_h5ad(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/ipsc/ipsc.h5ad'</span>)
x.X
</pre>
</div>

<pre class="example">
&lt;5597x9957 sparse matrix of type '&lt;class 'numpy.float32'&gt;'
with 39654337 stored elements in Compressed Sparse Row format&gt;
</pre>

<p>
Prepare the data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-comment-delimiter"># </span><span class="org-comment">Important: the dense data will fit on the GPU</span>
<span class="org-variable-name">y</span> = x.X.A
<span class="org-variable-name">s</span> = x.obs[<span class="org-string">'mol_hs'</span>].values.reshape(-1, 1)
<span class="org-variable-name">onehot</span> = ss.coo_matrix((np.ones(x.shape[0]), (np.arange(x.shape[0]), pd.Categorical(x.obs[<span class="org-string">'chip_id'</span>]).codes))).tocsr()
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: center the matrix of dummy variables (batch), because there is no</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">baseline</span>
<span class="org-variable-name">design</span> = ss.coo_matrix(pd.get_dummies(x.obs[<span class="org-string">'experiment'</span>])).astype(<span class="org-builtin">float</span>).A
<span class="org-variable-name">design</span> -= design.mean(axis=0)
</pre>
</div>

<p>
Fit <code>mpebpm</code>, and report the time elapsed in minutes.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">start</span> = time.time()
<span class="org-variable-name">log_mu</span>, <span class="org-variable-name">neg_log_phi</span>, <span class="org-variable-name">logodds</span> = mpebpm.ebpm_point_gamma(
  y,
  s=s,
  onehot=onehot,
  batch_size=64,
  lr=1e-2,
  max_epochs=80,
  verbose=<span class="org-constant">True</span>)
<span class="org-variable-name">elapsed</span> = time.time() - start
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-log-mu'</span>, log_mu)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-neg-log-phi'</span>, neg_log_phi)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-logodds'</span>, logodds)
elapsed / 60
</pre>
</div>

<pre class="example">
4.786360724767049

</pre>

<p>
For comparison, this analysis previously required 395 minutes using
<code>scqtl</code>. Estimate the full data log likelihood.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-log-mu.npy'</span>)
<span class="org-variable-name">neg_log_phi</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-neg-log-phi.npy'</span>)
<span class="org-variable-name">logodds</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-logodds.npy'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean</span> = s.ravel() * onehot @ np.exp(log_mu)
<span class="org-variable-name">inv_disp</span> = onehot @ np.exp(neg_log_phi)
<span class="org-variable-name">nb_llik</span> = (y * np.log(mean / inv_disp)
           - y * np.log(1 + mean / inv_disp)
           - inv_disp * np.log(1 + mean / inv_disp)
           <span class="org-comment-delimiter"># </span><span class="org-comment">Important: these terms are why we use inverse dispersion</span>
           + sp.gammaln(y + inv_disp)
           - sp.gammaln(inv_disp)
           - sp.gammaln(y + 1))
<span class="org-variable-name">case_zero</span> = -np.log1p(np.exp(onehot @ -logodds)) + np.log1p(np.exp(nb_llik - (onehot @ logodds)))
<span class="org-variable-name">case_non_zero</span> = -np.log1p(np.exp(onehot @ logodds)) + nb_llik
np.where(y &lt; 1, case_zero, case_non_zero).mean()
</pre>
</div>

<pre class="example">
-128.0825405344857

</pre>

<p>
Read the previously estimated parameters, and estimate the full data log
likelihood.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu0</span> = pd.read_table(<span class="org-string">"/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design0/zi2-log-mu.txt.gz"</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">log_phi0</span> = pd.read_table(<span class="org-string">"/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design0/zi2-log-phi.txt.gz"</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">logodds0</span> = pd.read_table(<span class="org-string">"/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design0/zi2-logodds.txt.gz"</span>, index_col=0, sep=<span class="org-string">' '</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean0</span> = s.ravel() * onehot @ np.exp(log_mu0.values.T)
<span class="org-variable-name">inv_disp0</span> = onehot @ np.exp(-log_phi0.values.T)
<span class="org-variable-name">nb_llik</span> = (y * np.log(mean0 / inv_disp0)
           - y * np.log(1 + mean0 / inv_disp0)
           - inv_disp0 * np.log(1 + mean0 / inv_disp0)
           <span class="org-comment-delimiter"># </span><span class="org-comment">Important: these terms are why we use inverse disp0ersion</span>
                + sp.gammaln(y + inv_disp0)
           - sp.gammaln(inv_disp0)
           - sp.gammaln(y + 1))
<span class="org-variable-name">case_zero</span> = -np.log1p(np.exp(onehot @ -logodds0.values.T)) + np.log1p(np.exp(nb_llik - (onehot @ logodds0.values.T)))
<span class="org-variable-name">case_non_zero</span> = -np.log1p(np.exp(onehot @ logodds0.values.T)) + nb_llik
np.where(y &lt; 1, case_zero, case_non_zero).mean()
</pre>
</div>

<pre class="example">
-248.24867762696132

</pre>

<p>
Plot the fitted values of the two methods against each other.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(1, 3)
fig.set_size_inches(7, 2.5)

ax[0].scatter(log_mu.ravel(order=<span class="org-string">'F'</span>), log_mu0.values.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[0].set_xlim(ax[0].get_ylim())
ax[0].plot(ax[0].get_xlim(), ax[0].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[0].set_xlabel(<span class="org-string">'MPEBPM est $\log(\mu)$'</span>)
ax[0].set_ylabel(<span class="org-string">'scqtl est $\log(\mu)$'</span>)

ax[1].scatter(-neg_log_phi.ravel(order=<span class="org-string">'F'</span>), log_phi0.values.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[1].set_xlim(ax[1].get_ylim())
ax[1].plot(ax[1].get_xlim(), ax[1].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[1].set_xlabel(<span class="org-string">'MPEBPM est $\log(\phi)$'</span>)
ax[1].set_ylabel(<span class="org-string">'scqtl est $\log(\phi)$'</span>)

ax[2].scatter(logodds.ravel(order=<span class="org-string">'F'</span>), logodds0.values.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[2].set_xlim(ax[2].get_ylim())
ax[2].plot(ax[2].get_xlim(), ax[2].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[2].set_xlabel(<span class="org-string">'MPEBPM est $\mathrm{logit}(\pi)$'</span>)
ax[2].set_ylabel(<span class="org-string">'scqtl est $\mathrm{logit}(\pi)$'</span>)

fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc.png" alt="mpebpm-ipsc.png">
</p>
</div>

<p>
Test each individual-gene combination for goodness-of-fit to the
<code>mpebpm</code>-estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = <span class="org-builtin">dict</span>()
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(x.shape[1]):
  <span class="org-keyword">for</span> k, donor <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(pd.Categorical(x.obs[<span class="org-string">'chip_id'</span>]).categories):
    <span class="org-variable-name">idx</span> = onehot[:,k].A.ravel().astype(<span class="org-builtin">bool</span>)
    <span class="org-variable-name">d</span>, <span class="org-variable-name">p</span> = scqtl.diagnostic.diagnostic_test(
      x.X[idx,j].A,
      log_mu[k,j],
      -neg_log_phi[k,j],
      -logodds[k,j],
      s[idx],
      np.ones((<span class="org-builtin">int</span>(idx.<span class="org-builtin">sum</span>()), 1)),
      n_samples=1)
    result[(donor, x.var.iloc[j].name)] = pd.Series({<span class="org-string">'stat'</span>: d, <span class="org-string">'p'</span>: p})
<span class="org-variable-name">result</span> = pd.DataFrame.from_dict(result, orient=<span class="org-string">'index'</span>)
<span class="org-variable-name">result.index.names</span> = [<span class="org-string">'donor'</span>, <span class="org-string">'gene'</span>]
<span class="org-variable-name">result</span> = result.reset_index()
</pre>
</div>

<p>
Write out the GOF tests.
</p>

<div class="org-src-container">
<pre class="src src-ipython">result.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-gof.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Plot the histogram of GOF \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result[<span class="org-string">'p'</span>], bins=np.linspace(0, 1, 11), color=<span class="org-string">'0.7'</span>, density=<span class="org-constant">True</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlim(0, 1)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc-gof.png" alt="mpebpm-ipsc-gof.png">
</p>
</div>

<p>
Report how many individual-gene combinations (proportion) depart
significantly from the estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sig</span> = result.loc[result[<span class="org-string">'p'</span>] &lt; 0.05 / result.shape[0]]
sig.shape[0], sig.shape[0] / result.shape[0]
</pre>
</div>

<pre class="example">
(64, 0.00011903034901930151)

</pre>

<p>
Look at one of the examples where the data depart from the estimated
distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 1)
fig.set_size_inches(6, 4)
<span class="org-variable-name">query</span> = x[x.obs[<span class="org-string">'chip_id'</span>] == sig.iloc[0][<span class="org-string">'donor'</span>], x.var.index == sig.iloc[0][<span class="org-string">'gene'</span>]].X.A.ravel()
ax[0].hist(query, bins=np.arange(query.<span class="org-builtin">max</span>() + 1), color=<span class="org-string">'k'</span>)
ax[0].set_xlabel(<span class="org-string">'Number of molecules'</span>)
ax[0].set_ylabel(<span class="org-string">'Number of cells'</span>)
ax[0].set_title(x.var.loc[sig.iloc[0][<span class="org-string">'gene'</span>], <span class="org-string">'name'</span>])

<span class="org-variable-name">grid</span> = np.linspace(0, 1e-3, 1000)
<span class="org-variable-name">j</span> = <span class="org-builtin">list</span>(x.var.index).index(sig.iloc[0][<span class="org-string">'gene'</span>])
<span class="org-variable-name">k</span> = <span class="org-builtin">list</span>(pd.Categorical(x.obs[<span class="org-string">'chip_id'</span>]).categories).index(sig.iloc[0][<span class="org-string">'donor'</span>])
ax[1].plot(grid, st.gamma(a=np.exp(neg_log_phi[k,j]), scale=np.exp(log_mu[k,j] - neg_log_phi[k,j])).cdf(grid), c=<span class="org-string">'k'</span>, lw=1)
ax[1].set_xlabel(<span class="org-string">'Latent gene expression'</span>)
ax[1].set_ylabel(<span class="org-string">'CDF'</span>)

fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc-ex.png" alt="mpebpm-ipsc-ex.png">
</p>
</div>

<p>
Report all genes at which the data depart from the estimated distribution
for at least one individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython">x.var.merge(sig, left_index=<span class="org-constant">True</span>, right_on=<span class="org-string">'gene'</span>, how=<span class="org-string">'inner'</span>)[<span class="org-string">'name'</span>].unique()
</pre>
</div>

<pre class="example">
array(['NUP98', 'ANXA5', 'RPL27A', 'RHOG', 'MT-CO2', 'MT-ND4', 'MT-CO3',
'MT-ND4L', 'MT-ATP8'], dtype=object)
</pre>
</div>
</div>

<div id="outline-container-org1a9953a" class="outline-3">
<h3 id="org1a9953a">Confounder correction in iPSC data</h3>
<div class="outline-text-3" id="text-org1a9953a">
<p>
Repeat the analysis, including batch as a covariate.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">start</span> = time.time()
<span class="org-variable-name">log_mu1</span>, <span class="org-variable-name">neg_log_phi1</span>, <span class="org-variable-name">logodds1</span>, <span class="org-variable-name">bhat1</span> = mpebpm.sgd.ebpm_point_gamma(
  y,
  s=s,
  onehot=onehot,
  design=design,
  batch_size=64,
  lr=1e-2,
  max_epochs=100,
  verbose=<span class="org-constant">True</span>)
<span class="org-variable-name">elapsed</span> = time.time() - start
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-log-mu'</span>, log_mu)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-neg-log-phi'</span>, neg_log_phi)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-logodds'</span>, logodds)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-bhat'</span>, bhat)
elapsed / 60
</pre>
</div>

<pre class="example">
3.198907784620921

</pre>

<p>
Read the <code>mpebpm</code> and <code>scqtl</code> estimates.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-log-mu.npy'</span>)
<span class="org-variable-name">neg_log_phi1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-neg-log-phi.npy'</span>)
<span class="org-variable-name">logodds1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-logodds.npy'</span>)
<span class="org-variable-name">bhat1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-bhat.npy'</span>)

<span class="org-variable-name">log_mu2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">log_phi2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">logodds2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">bhat2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/beta.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
</pre>
</div>

<p>
Compute the full data log likelihood at the <code>mpebpm</code> solution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean</span> = s.ravel() * onehot @ np.exp(log_mu1) * np.exp(design @ bhat1)
<span class="org-variable-name">inv_disp</span> = onehot @ np.exp(neg_log_phi1)
<span class="org-variable-name">nb_llik</span> = (y * np.log(mean / inv_disp)
           - y * np.log(1 + mean / inv_disp)
           - inv_disp * np.log(1 + mean / inv_disp)
           <span class="org-comment-delimiter"># </span><span class="org-comment">Important: these terms are why we use inverse dispersion</span>
           + sp.gammaln(y + inv_disp)
           - sp.gammaln(inv_disp)
           - sp.gammaln(y + 1))
<span class="org-variable-name">case_zero</span> = -np.log1p(np.exp(onehot @ -logodds1)) + np.log1p(np.exp(nb_llik - (onehot @ logodds1)))
<span class="org-variable-name">case_non_zero</span> = -np.log1p(np.exp(onehot @ logodds1)) + nb_llik
np.where(y &lt; 1, case_zero, case_non_zero).mean()
</pre>
</div>

<pre class="example">
-222.59761148808386

</pre>

<p>
Compute the full data log likelihood at the <code>scqtl</code> solution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean</span> = s.ravel() * onehot @ np.exp(log_mu2.values.T) * np.exp(design @ bhat2.values.T)
<span class="org-variable-name">inv_disp</span> = onehot @ np.exp(-log_phi2.values.T)
<span class="org-variable-name">nb_llik</span> = (y * np.log(mean / inv_disp)
           - y * np.log(1 + mean / inv_disp)
           - inv_disp * np.log(1 + mean / inv_disp)
           <span class="org-comment-delimiter"># </span><span class="org-comment">Important: these terms are why we use inverse dispersion</span>
           + sp.gammaln(y + inv_disp)
           - sp.gammaln(inv_disp)
           - sp.gammaln(y + 1))
<span class="org-variable-name">case_zero</span> = -np.log1p(np.exp(onehot @ -logodds2.values.T)) + np.log1p(np.exp(nb_llik - (onehot @ logodds2.values.T)))
<span class="org-variable-name">case_non_zero</span> = -np.log1p(np.exp(onehot @ logodds2.values.T)) + nb_llik
np.where(y &lt; 1, case_zero, case_non_zero).mean()
</pre>
</div>

<pre class="example">
-349.2031033227098

</pre>

<p>
Compare the <code>mpebpm</code> estimates with and without correcting for batch.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(1, 3)
fig.set_size_inches(7, 2.5)

ax[0].scatter(log_mu.ravel(), log_mu1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[0].set_xlim(ax[0].get_ylim())
ax[0].plot(ax[0].get_xlim(), ax[0].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[0].set_xlabel(<span class="org-string">'Est $\log(\mu)$'</span>)
ax[0].set_ylabel(<span class="org-string">'Corrected est $\log(\mu)$'</span>)

ax[1].scatter(-neg_log_phi.ravel(), -neg_log_phi1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[1].set_xlim(ax[1].get_ylim())
ax[1].plot(ax[1].get_xlim(), ax[1].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[1].set_xlabel(<span class="org-string">'Est $\log(\phi)$'</span>)
ax[1].set_ylabel(<span class="org-string">'Corrected est $\log(\phi)$'</span>)

ax[2].scatter(logodds.ravel(), logodds1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[2].set_xlim(ax[2].get_ylim())
ax[2].plot(ax[2].get_xlim(), ax[2].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[2].set_xlabel(<span class="org-string">'Est $\mathrm{logit}(\pi)$'</span>)
ax[2].set_ylabel(<span class="org-string">'Corrected est $\mathrm{logit}(\pi)$'</span>)

fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc-design.png" alt="mpebpm-ipsc-design.png">
</p>
</div>

<p>
Compare the <code>mpebpm</code> estimate against the <code>scqtl</code> estimate (with confounder
correction).
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 2)
fig.set_size_inches(5, 5)

ax[0,0].scatter(log_mu2.values.ravel(order=<span class="org-string">'F'</span>), log_mu1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[0,0].set_xlim(ax[0,0].get_ylim())
ax[0,0].plot(ax[0,0].get_xlim(), ax[0,0].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[0,0].set_xlabel(<span class="org-string">'scqtl $\log(\mu)$'</span>)
ax[0,0].set_ylabel(<span class="org-string">'mpebpm est $\log(\mu)$'</span>)

ax[0,1].scatter(log_phi2.values.ravel(order=<span class="org-string">'F'</span>), -neg_log_phi1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[0,1].set_xlim(ax[0,1].get_ylim())
ax[0,1].plot(ax[0,1].get_xlim(), ax[0,1].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[0,1].set_xlabel(<span class="org-string">'scqtl est $\log(\phi)$'</span>)
ax[0,1].set_ylabel(<span class="org-string">'mpebpm est $\log(\phi)$'</span>)

ax[1,0].scatter(logodds2.values.ravel(order=<span class="org-string">'F'</span>), logodds1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[1,0].set_xlim(ax[1,0].get_ylim())
ax[1,0].plot(ax[1,0].get_xlim(), ax[1,0].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[1,0].set_xlabel(<span class="org-string">'scqtl est $\mathrm{logit}(\pi)$'</span>)
ax[1,0].set_ylabel(<span class="org-string">'mpebpm est $\mathrm{logit}(\pi)$'</span>)

ax[1,1].scatter(bhat2.values.ravel(order=<span class="org-string">'F'</span>), bhat1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[1,1].set_xlim(ax[1,1].get_ylim())
ax[1,1].plot(ax[1,1].get_xlim(), ax[1,1].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[1,1].set_xlabel(r<span class="org-string">'scqtl est $\beta$'</span>)
ax[1,1].set_ylabel(r<span class="org-string">'mpebpm est $\beta$'</span>)

<span class="org-keyword">for</span> a <span class="org-keyword">in</span> ax.ravel():
  a.set_aspect(<span class="org-string">'equal'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/scqtl-mpebpm-design.png" alt="scqtl-mpebpm-design.png">
</p>
</div>

<p>
Fit a <i>susie</i> model (Wang et al. 2018) for each gene \(j\), regressing
\(E[\lambda_{ij}]\) against <i>cis</i>-genotypes within the interval (TSS - 1MB,
TES + 1MB).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mean</span> = -np.log1p(np.exp(logodds1)) + log_mu1
<span class="org-variable-name">window</span> = 1e6
<span class="org-keyword">with</span> gzip.<span class="org-builtin">open</span>(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/yri-120-dosages.vcf.gz'</span>, <span class="org-string">'rt'</span>) <span class="org-keyword">as</span> f:
  <span class="org-keyword">for</span> line <span class="org-keyword">in</span> f:
    <span class="org-keyword">if</span> line.startswith(<span class="org-string">'#CHROM'</span>):
      <span class="org-variable-name">header</span> = line.split()
      <span class="org-keyword">break</span>
<span class="org-variable-name">f</span> = tabix.<span class="org-builtin">open</span>(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/scqtl-mapping/yri-120-dosages.vcf.gz'</span>)
<span class="org-keyword">for</span> (k, v), pheno <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(x.var.iterrows(), log_mean.T):
  <span class="org-keyword">if</span> k != <span class="org-string">'ENSG00000113558'</span>:
    <span class="org-keyword">continue</span>
  <span class="org-keyword">try</span>:
    <span class="org-variable-name">query</span> = pd.DataFrame(<span class="org-builtin">list</span>(f.query(f<span class="org-string">'chr{v["chr"][2:]}'</span>, v[<span class="org-string">'start'</span>] - <span class="org-builtin">int</span>(window), v[<span class="org-string">'start'</span>] + <span class="org-builtin">int</span>(window))))
    <span class="org-variable-name">query.columns</span> = header
    <span class="org-variable-name">dose</span> = query.<span class="org-builtin">filter</span>(like=<span class="org-string">'NA'</span>, axis=1).astype(<span class="org-builtin">float</span>).T
    <span class="org-variable-name">dose.columns</span> = query[<span class="org-string">'POS'</span>]
  <span class="org-keyword">except</span> tabix.TabixError:
    <span class="org-keyword">continue</span>
  <span class="org-variable-name">pheno</span> = pd.Series(pheno, index=x.obs[<span class="org-string">'chip_id'</span>].unique())
  <span class="org-keyword">del</span> pheno[<span class="org-string">'NA18498'</span>]
  <span class="org-variable-name">dose</span>, <span class="org-variable-name">pheno</span> = dose.align(pheno, axis=0, join=<span class="org-string">'inner'</span>)
  <span class="org-variable-name">fit</span> = susie.susie(dose.values, pheno.values, L=10, standardize=<span class="org-constant">True</span>)
  <span class="org-keyword">break</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.scatter(dose[<span class="org-string">"133515530"</span>], pheno, c=<span class="org-string">'k'</span>, s=2)
plt.xlabel(<span class="org-string">'Dosage'</span>)
plt.ylabel(<span class="org-string">'Log latent mean gene expression'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/skp1.png" alt="skp1.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org450128b" class="outline-3">
<h3 id="immune-census"><a id="org450128b"></a>Application to Census of Immune Cells</h3>
<div class="outline-text-3" id="text-immune-census">
<p>
The
<a href="https://data.humancellatlas.org/explore/projects/cc95ff89-2e68-4a08-a234-480eca21ce79">Census
of Immune Cells</a> is part of the Human Cell Atlas. Currently, it comprises
scRNA-seq data of 593,844 cells from 16 donors. To demonstrate the scalability of
<code>mpebpm</code>, fit a Gamma distribution to each gene in each donor.
</p>

<p>
Read the sparse data, filter out genes which are all 0 in some individual,
and report its dimensions. This is much faster than reading <code>h5ad</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">y_csr</span> = ss.load_npz(<span class="org-string">'/scratch/midway2/aksarkar/modes/immune-cell-census.npz'</span>)
<span class="org-variable-name">y_csc</span> = y_csr.tocsc()
<span class="org-comment-delimiter"># </span><span class="org-comment">keep = (((onehot.T @ y_csc) &gt; 0).sum(axis=0) == len(donor.categories)).A.ravel()</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">y_csc = y_csc[keep]</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">y_csr = y_csc.tocsr()</span>
<span class="org-variable-name">s</span> = y_csr.<span class="org-builtin">sum</span>(axis=1).A.ravel()
<span class="org-variable-name">genes</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/modes/immune-cell-census-genes.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
<span class="org-variable-name">donor</span> = pd.Categorical(pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/modes/immune-cell-census-samples.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)[<span class="org-string">'0'</span>])
<span class="org-variable-name">onehot</span> = ss.coo_matrix((np.ones(donor.shape[0]).astype(np.float32), (np.arange(donor.shape[0]), donor.codes))).tocsr()
y_csr
</pre>
</div>

<pre class="example">
&lt;593844x16002 sparse matrix of type '&lt;class 'numpy.int32'&gt;'
with 551836788 stored elements in Compressed Sparse Row format&gt;
</pre>

<p>
Fit <code>mpebpm</code>, and report the time elapsed in minutes.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">start</span> = time.time()
<span class="org-variable-name">log_mu</span>, <span class="org-variable-name">neg_log_phi</span> = mpebpm.sgd.ebpm_gamma(y_csr, onehot=onehot, batch_size=64, lr=1e-2, max_epochs=10, shuffle=<span class="org-constant">True</span>, verbose=<span class="org-constant">True</span>)
<span class="org-variable-name">elapsed</span> = time.time() - start
pd.DataFrame(log_mu, index=donor.categories, columns=genes[<span class="org-string">'featurekey'</span>]).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/immune-census-log-mu.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
pd.DataFrame(neg_log_phi, index=donor.categories, columns=genes[<span class="org-string">'featurekey'</span>]).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/immune-census-neg-log-phi.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
pd.DataFrame(logodds, index=donor.categories, columns=genes[<span class="org-string">'featurekey'</span>]).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/immune-census-logodds.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
elapsed / 60
</pre>
</div>

<p>
Read the estimated parameters.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/immune-census-log-mu.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
<span class="org-variable-name">neg_log_phi</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/immune-census-neg-log-phi.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
<span class="org-variable-name">logodds</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/immune-census-logodds.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
</pre>
</div>

<p>
Test each donor-gene combination for goodness-of-fit to the
<code>mpebpm</code>-estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = <span class="org-builtin">dict</span>()
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(y_csr.shape[1]):
  <span class="org-variable-name">query</span> = y_csc[:,j].tocsr()
  <span class="org-keyword">for</span> k, name <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(donor.categories):
    <span class="org-variable-name">idx</span> = onehot[:,k].tocsc().indices
    <span class="org-variable-name">N</span> = idx.shape[0]
    <span class="org-variable-name">x</span> = query[idx].A.ravel()
    <span class="org-variable-name">n</span> = np.exp(-neg_log_phi.iloc[k,j])
    <span class="org-variable-name">p</span> = 1 / (1 + s[idx] * np.exp(log_mu.iloc[k,j] - neg_log_phi.iloc[k,j]))         
    <span class="org-variable-name">pi0</span> = sp.expit(-logodds.iloc[k,j])
    <span class="org-variable-name">F</span> = st.nbinom(n=n, p=p)
    <span class="org-variable-name">Fx_1</span> = F.cdf(x - 1)
    <span class="org-variable-name">Fx_1</span> = np.where(x &gt; 0, pi0 + (1 - pi0) * Fx_1, Fx_1)
    <span class="org-variable-name">fx</span> = F.pmf(x)
    <span class="org-variable-name">u</span> = np.random.uniform(size=N)
    <span class="org-variable-name">d</span>, <span class="org-variable-name">p</span> = st.kstest(Fx_1 + u * fx, <span class="org-string">'uniform'</span>)
    result[(name, genes.iloc[j][<span class="org-string">'Gene'</span>])] = pd.Series({<span class="org-string">'stat'</span>: d, <span class="org-string">'p'</span>: p})

<span class="org-variable-name">result</span> = pd.DataFrame.from_dict(result, orient=<span class="org-string">'index'</span>)
<span class="org-variable-name">result.index.names</span> = [<span class="org-string">'donor'</span>, <span class="org-string">'gene'</span>]
<span class="org-variable-name">result</span> = result.reset_index()
result.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-gof.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Plot the histogram of GOF \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result[<span class="org-string">'p'</span>], bins=np.linspace(0, 1, 11), color=<span class="org-string">'0.7'</span>, density=<span class="org-constant">True</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/immune-census-gof.png" alt="immune-census-gof.png">
</p>
</div>

<p>
Look at an example.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 1)

<span class="org-variable-name">j</span> = 1
<span class="org-variable-name">k</span> = 0
<span class="org-variable-name">query</span> = y_csc[:,k].tocsr()
<span class="org-variable-name">idx</span> = onehot[:,j].tocsc().indices
<span class="org-variable-name">x</span> = query[idx].A.ravel()
ax[0].hist(x, bins=np.arange(x.<span class="org-builtin">max</span>() + 2), color=<span class="org-string">'k'</span>)
ax[0].set_xlabel(<span class="org-string">'Number of molecules'</span>)
ax[0].set_ylabel(<span class="org-string">'Number of cells'</span>)
ax[0].set_title(genes.iloc[1][<span class="org-string">'Gene'</span>])

<span class="org-variable-name">grid</span> = np.linspace(0, 1e-5, 1000)
<span class="org-variable-name">pi0</span> = sp.expit(-logodds.iloc[k,j])
<span class="org-variable-name">F</span> = pi0 + (1 - pi0) * st.gamma(a=np.exp(-neg_log_phi.iloc[k,j]), scale=np.exp(log_mu.iloc[k,j] - neg_log_phi.iloc[k,j])).cdf(grid)
ax[1].plot(grid, F, c=<span class="org-string">'k'</span>, lw=1)
ax[1].set_xlabel(<span class="org-string">'Latent gene expression'</span>)
ax[1].set_ylabel(<span class="org-string">'CDF'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/ic-dpm1.png" alt="ic-dpm1.png">
</p>
</div>

<p>
Fit just this gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython">scmodes.ebpm.ebpm_point_gamma(x, s[idx].ravel())
</pre>
</div>

<pre class="example">
(-12.289583305728296,
14.014278232411597,
0.9672324267648861,
-857.9082245516674)
</pre>


<div class="org-src-container">
<pre class="src src-ipython">log_mu.iloc[k,j], neg_log_phi.iloc[k,j], logodds.iloc[k,j]
</pre>
</div>

<pre class="example">
(-9.686181, 1.9767971999999998, -1.9064716)

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2020-05-08 Fri 01:05</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
