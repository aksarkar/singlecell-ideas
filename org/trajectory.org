#+TITLE: Cardiac trajectory prediction
#+SETUPFILE: setup.org

* Setup                                                            :noexport:

  #+BEGIN_SRC emacs-lisp
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(memory="4G",venv="singlecell",opts="-c4") :dir /scratch/midway2/aksarkar/ideas

  #+RESULTS:
  : Submitted batch job 53706819

  #+NAME: imports
  #+BEGIN_SRC ipython
    import anndata
    import gzip
    import numpy as np
    import pandas as pd
    import scanpy.api as sc
    import scipy.io as si
    import scipy.sparse as ss
    import scipy.stats as st
    import scvi.dataset
    import scvi.models
    import scvi.inference
    import sklearn.decomposition as skd
    import umap
  #+END_SRC

  #+RESULTS: imports
  :RESULTS:
  # Out[1]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
    import colorcet
    import matplotlib.pyplot as plt
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

* Introduction

  Here, we investigate analogues of principal curves ([[https://www.tandfonline.com/doi/abs/10.1080/01621459.1989.10478797][Hastie and Stuetzle 1989]])
  in other embeddings. 

  The goal is to qualitatively evaluate the ability to follow gene expression
  in the observed space by walking along trajectories in the embedding space,
  to recover key events in differentiation time courses.

* Materials and methods
** iPSC-derived cardiomyocyte differentiation time course data

   We differentiated iPSCs into cardiomyocytes from two individuals, and
   performed Drop-Seq and DroNC-Seq at 4 and 5 time points respectively: 0, 1,
   3, 7, and 15 days.

   Read and compress the Drop-Seq data.

   #+BEGIN_SRC ipython :async t
     data = pd.read_table('/project2/onibasu/data/project_CZI/DROP_combined_counts.tsv.gz', index_col=0)
     counts = ss.csr_matrix(data.values)
     with gzip.open('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/counts.mtx.gz', 'wb') as f:
       si.mmwrite(f, counts)
     data.index.to_series().to_csv('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/genes.txt', index=None)
     pd.DataFrame(data.columns.to_series().apply(lambda x: pd.Series(x.split('_')))).to_csv('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/cells.txt', index=None, sep=' ')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

   Read the compressed data.

   #+BEGIN_SRC ipython
     counts = si.mmread('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/counts.mtx.gz')
     genes = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/genes.txt', header=None, index_col=0)
     cells = pd.read_table('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/cells.txt', sep=' ')
     cells.columns = ['barcode', 'day', 'ind']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[3]:
   :END:

   Keep genes detected in at least 10% of cells.

   #+BEGIN_SRC ipython
     adata = anndata.AnnData(counts.T.tocsr(), obs=cells, var=genes)
     sc.pp.filter_genes(adata, min_cells=.1 * adata.shape[0])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[16]:
   :END:

* Results
** scVI

   Fit scVI to the data.

   #+BEGIN_SRC ipython :async t
     X = scvi.dataset.GeneExpressionDataset(
        ,*scvi.dataset.GeneExpressionDataset.get_attributes_from_matrix(
         adata.X,
         batch_indices=np.array([i == 'rep1' for i in adata.obs['ind']]).astype(int),
         labels=adata.obs['day'].values,
       ))
     model = scvi.models.VAE(X.nb_genes, n_batch=X.n_batches, n_latent=10)
     infer = scvi.inference.UnsupervisedTrainer(model=model, gene_dataset=X)
     infer.train(n_epochs=200, lr=1e-2)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

   #+BEGIN_SRC ipython
     adata.obsm['X_scvi'] = 
     sc.pp.neighbors(adata, use_rep='X_nmf')
     sc.tl.diffmap(adata)
   #+END_SRC

** NMF
   
   Our benchmarking suggests NMF learns the best low rank structure of the
   rates.

   #+BEGIN_SRC ipython
     m = skd.NMF(n_components=10, solver='mu', beta_loss=1).fit(adata.X)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

   #+BEGIN_SRC ipython
     loadings = m.transform(adata.X)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[15]:
   :END:

   Remove the library size.

   #+BEGIN_SRC ipython
     L = loadings / adata.X.sum(axis=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[23]:
   :END:

   Look at the diffusion maps.

   #+BEGIN_SRC ipython :async t
     adata.obsm['X_nmf'] = L
     rep1 = adata[adata.obs['ind'] == 'Rep1']
     sc.pp.neighbors(rep1, use_rep='X_nmf')
     sc.tl.diffmap(rep1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

   #+BEGIN_SRC ipython
     rep2 = adata[adata.obs['ind'] == 'Rep2']
     sc.pp.neighbors(rep2, use_rep='X_nmf')
     sc.tl.diffmap(rep2)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[100]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/trajectory.org/drop-seq-nmf-diffusion.png
     from mpl_toolkits.mplot3d import Axes3D

     plt.clf()
     plt.gcf().set_size_inches(4, 4)
     ax = plt.gcf().add_subplot(111, projection='3d')
     for i, (k, g) in enumerate(rep2.obs.groupby('day')):
       ax.scatter(rep2.obsm['X_diffmap'][rep2.obs['day'] == k,1],
                   rep2.obsm['X_diffmap'][rep2.obs['day'] == k,2],
                   rep2.obsm['X_diffmap'][rep2.obs['day'] == k,3],
                   c=f'C{i}', s=1, alpha=.1, label=k)

     ax.set_xlabel('Diffusion map 1')
     ax.set_ylabel('Diffusion map 2')
     ax.set_zlabel('Diffusion map 3')

     leg = plt.legend(frameon=False, handletextpad=0, markerscale=4, loc='center left', bbox_to_anchor=(1, .5))
     for h in leg.legendHandles: 
       h.set_alpha(1)

     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[101]:
   [[file:figure/trajectory.org/drop-seq-nmf-diffusion.png]]
   :END:

   Compute diffusion psuedotime.

   #+BEGIN_SRC ipython
     np.random.seed(1)
     dpt = []
     for root in np.random.choice(rep1.obs[rep1.obs['day'] == 0].index, 200):
       rep1.uns['iroot'] = root
       sc.tl.dpt(rep1, n_dcs=15)
       dpt.append(rep1.obs['dpt_pseudotime'])
     dpt = np.array(dpt).T
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[130]:
   :END:

   Look at pseudotime vs. real time.

   #+BEGIN_SRC ipython :ipyfile figure/trajectory.org/drop-seq-nmf-dpt.png
     plt.clf()
     plt.gcf().set_size_inches(3, 6)
     for i, (k, _) in enumerate(rep1.obs.groupby('day')):
       plt.errorbar(x=dpt[rep1.obs['day'] == k].mean(axis=1),
                    y=np.arange(rep1.shape[0])[rep1.obs['day'] == k],
                    yerr=dpt[rep1.obs['day'] == k].std(axis=1),
                    c=f'C{i}',
                    label=k)
     plt.xlabel('Diffusion pseudotime')
     plt.ylabel('Cell')
     leg = plt.legend()
     leg.set_title('Day')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[131]:
   [[file:figure/trajectory.org/drop-seq-nmf-dpt.png]]
   :END:

   Read off gene expression over DPT trajectories.

   #+BEGIN_SRC ipython
     lam = L.dot(m.components_)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[132]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/trajectory.org/drop-seq-nmf-dpt-markers.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.scatter(dpt.mean(axis=1), lam[adata.obs['ind'] == 'Rep1',np.where(rep1.var_names == 'MYL7')[0]].A.ravel(), s=1)
     plt.xlabel('Diffusion pseudotime')
     plt.ylabel('Latent expression')
     plt.title('MYL7')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[162]:
   : Text(0.5,1,'MYL7')
   [[file:figure/trajectory.org/drop-seq-nmf-dpt-markers.png]]
   :END:

   Investigate whether reverse pseudotime will perform better. First, see if we
   can confidently separate terminal cardiomyocytes.

   #+BEGIN_SRC ipython
     m.components_[:,np.where(rep1.var_names == 'MYL7')[0]]
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[165]:
   #+BEGIN_EXAMPLE
     array([[ 0.0430656473],
     [ 3.7637520339],
     [ 0.          ],
     [ 0.0259073463],
     [18.4579867492],
     [ 0.          ],
     [ 0.          ],
     [ 0.0441971002],
     [ 0.          ],
     [ 0.          ]])
   #+END_EXAMPLE
   :END:

   Look at linear separability in the largest latent factors.

   #+BEGIN_SRC ipython :ipyfile figure/trajectory.org/drop-seq-nmf-dpt-terminal.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.semilogx()
     plt.semilogy()
     expr = lam[adata.obs['ind'] == 'Rep1',np.where(rep1.var_names == 'MYL7')[0]].A.ravel()
     plt.scatter(L[adata.obs['ind'] == 'Rep1',0].A, L[adata.obs['ind'] == 'Rep1',4].A, s=1, c=colorcet.cm['fire'](expr / expr.max()))
     plt.xlabel('Factor 1')
     plt.ylabel('Factor 5')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[175]:
   : Text(0,0.5,'Factor 5')
   [[file:figure/trajectory.org/drop-seq-nmf-dpt-terminal.png]]
   :END:

   Look at factor 5 vs. DPT.

   #+BEGIN_SRC ipython :ipyfile figure/trajectory.org/drop-seq-nmf-dpt-factor5.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.scatter(dpt.mean(axis=1), L[adata.obs['ind'] == 'Rep1',4].A, s=1)
     plt.xlabel('Diffusion pseudotime')
     plt.ylabel('Loading on factor 5')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[178]:
   : Text(0,0.5,'Loading on factor 5')
   [[file:figure/trajectory.org/drop-seq-nmf-dpt-factor5.png]]
   :END:

** Geodesics

   Estimate the geodesic in this space
   (https://www.springer.com/us/book/9780817634902, https://arxiv.org/pdf/1411.7432
   https://arxiv.org/abs/1710.11379).

   #+BEGIN_SRC ipython
     metric = m.components_.dot(m.components_.T)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[129]:
   :END:

   #+BEGIN_SRC ipython :async t
     import scipy.integrate

     def f(x, y):
       return np.vstack((y[], -.5 * np.linalg.pinv(metric), np.kron(y[1], y[1])))

     def bc(ya, yb):
       return np.array([ya - loadings[start][0], yb - loadings[end][0]])

     x = np.linspace(0, 1, 5)
     res = scipy.integrate.solve_bvp(f, bc, x, np.zeros((20, x.size)))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   0 - f554087f-b03a-4574-8613-072c205e5251
   :END:
