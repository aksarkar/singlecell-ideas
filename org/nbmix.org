#+TITLE: Model-based clustering of scRNA-seq data
#+SETUPFILE: setup.org

* Introduction

  Two major strategies for clustering scRNA-seq data are:

  1. Building a \(k\)-nearest neighbor graph on the data, and applying a
     community detection algorithm (e.g.,
     [[https://doi.org/10.1088/1742-5468/2008/10/P10008][Blondel et al. 2008]],
     [[https://arxiv.org/abs/1810.08473][Traag et al. 2018]])
  2. Fitting a topic model to the data
     (e.g., [[https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1006599][Dey
     et al. 2017]],
     [[https://www.nature.com/articles/s41592-019-0367-1][GonzÃ¡les-Blas et
     al. 2019]])

  The main disadvantage of strategy (1) is that, as commonly applied to
  transformed counts, it does not separate measurement error and biological
  variation of interest. The main disadvantage of strategy (2) is that it does
  not account for transcriptional noise
  ([[https://doi.org/10.1016/j.cell.2008.09.050][Raj 2008]]). Here, we develop
  a simple model-based clustering algorithm which addresses both of these
  issues.

* Setup
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 2

  #+CALL: ipython3(venv="singlecell",partition="gpu2",opts="--gres=gpu:1",memory="16G") :exports none :dir /scratch/midway2/aksarkar/singlecell/

  #+BEGIN_SRC ipython
    import anndata
    import mpebpm.gam_mix
    import mpebpm.sgd
    import numpy as np
    import pandas as pd
    import scanpy as sc
    import scipy.optimize as so
    import scipy.special as sp
    import scipy.stats as st
    import torch
    import torch.utils.data as td
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[12]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
    plt.rcParams['font.family'] = 'Nimbus Sans'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

  #+CALL: tensorboard(venv="singlecell") :session tensorboard :dir /scratch/midway2/aksarkar/singlecell/

* Method

  We assume \(
  \DeclareMathOperator\Gam{Gamma}
  \DeclareMathOperator\Mult{Multinomial}
  \DeclareMathOperator\N{\mathcal{N}}
  \DeclareMathOperator\Pois{Poisson}
  \newcommand\mi{\mathbf{I}}
  \newcommand\vmu{\boldsymbol{\mu}}
  \newcommand\vphi{\boldsymbol{\phi}}
  \newcommand\vpi{\boldsymbol{\pi}}
  \)

  \begin{align}
    x_{ij} \mid x_{i+}, \lambda_{ij} &\sim \Pois(x_{i+} \lambda_{ij})\\
    \lambda_{ij} \mid \vpi, \vmu, \vphi &\sim \sum_{k=1}^{K} \pi_{ik} \Gam(\phi_{kj}^{-1}, \phi_{kj}^{-1}\mu_{kj}^{-1}),
  \end{align}

  where

  - \(x_{ij}\) denotes the number of molecules of gene \(j\) observed in cell \(i\)
  - \(x_{i+} \triangleq \sum_j x_{ij}\) denotes the total number of molecules
    observed in cell \(i\)
  - \(\vpi_i\) denotes cluster assignment probabilities for cell \(i\)
  - \(\vmu_k\) denotes the cluster "centroid" for cluster \(k\), and
    \(\vphi_k\) describes stochastic perturbations within each cluster

  The intuition behind this model is that each cluster \(k\) is defined by a
  collection of independent Gamma distributions, one per gene \(j\). These
  Gamma distributions describe the distribution of true gene expression for
  each gene in each cluster
  ([[https://dx.doi.org/10.1101/2020.04.07.030007][Sarkar and Stephens 2020]]).
  
  We can estimate \(\vpi, \vmu, \vphi\) by maximizing the likelihood using an
  EM algorithm. Letting \(z_{ik} \in \{0, 1\}\) indicate whether cell \(i\) is
  assigned to cluster \(k\), in the E step

  \begin{equation}
    E[z_{ik}] \propto \sum_j \int_0^{\infty} \Pois(x_{ij}; x_{i+}\lambda) \Gam(\lambda; \phi_{kj}^{-1}, \phi_{kj}^{-1}\mu_{kj}^{-1})\, d\lambda.
  \end{equation}

  In the M step, we improve the weighted mixture of negative binomials
  likelihood by [[file:mepbpm.org][(batch) gradient descent]], implemented in
  the Python package ~mpebpm~. To make the model more amenable to stochastic
  gradient descent, we can amortize inference by learning a neural network
  mapping \(x_{i\cdot} \rightarrow z_{i\cdot}\).

  The posterior distribution of true gene expression given the data is

  \begin{equation}
    \lambda_{ij} \mid x_{ij}, x_{i+}, \vpi, \vmu, \vphi \sim \sum_{k=1}^{K} \pi_{ik} \Gam(x_{ij} + \phi_{kj}^{-1}, x_{i+} + \phi_{kj}^{-1}\mu_{kj}^{-1}).
  \end{equation}

* Results
** Example

   Read sorted immune cell scRNA-seq data
   ([[https://dx.doi.org/10.1038/ncomms14049][Zheng et al. 2017]]).

   #+BEGIN_SRC ipython :async t
     dat = anndata.read_h5ad('/scratch/midway2/aksarkar/ideas/zheng-10-way.h5ad')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[4]:
   :END:

   Get 256 B cells and 256 cytotoxic T cells.

   #+BEGIN_SRC ipython :async t
     b_cells = dat[dat.obs['cell_type'] == 'b_cells']
     # Important: this has a set seed
     sc.pp.subsample(b_cells, n_obs=256)
     t_cells = dat[dat.obs['cell_type'] == 'cytotoxic_t']
     sc.pp.subsample(t_cells, n_obs=256)
     temp = b_cells.concatenate(t_cells)
     sc.pp.filter_genes(temp, min_counts=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[5]:
   :END:

   Plot a UMAP embedding of the data, coloring points by the ground truth
   labels.

   #+BEGIN_SRC ipython :async t
     sc.pp.pca(temp)
     sc.pp.neighbors(temp)
     sc.tl.umap(temp)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/sim-ex.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, c in enumerate(temp.obs['cell_type'].unique()):
       plt.plot(*temp[temp.obs['cell_type'] == c].obsm["X_umap"].T, c=cm(i), marker='.', ms=2, lw=0, label=f'{c}')
     plt.legend(frameon=False, markerscale=4, handletextpad=0)
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[10]:
   [[file:figure/nbmix.org/sim-ex.png]]
   :END:

*** Leiden algorithm

    Apply the Leiden algorithm ([[https://arxiv.org/abs/1810.08473][Traag et
    al. 2018]]) to the data (~1 s).

    #+BEGIN_SRC ipython :async t
      sc.tl.leiden(temp)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[7]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/leiden-ex.png
      cm = plt.get_cmap('Dark2')
      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      for i, c in enumerate(temp.obs['leiden'].unique()):
        plt.plot(*temp[temp.obs['leiden'] == c].obsm["X_umap"].T, c=cm(i), marker='.', ms=2, lw=0, label=f'Cluster {i}')
      plt.legend(frameon=False, markerscale=4, handletextpad=0)
      plt.xlabel('UMAP 1')
      plt.ylabel('UMAP 2')
      plt.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[9]:
    [[file:figure/nbmix.org/leiden-ex.png]]
    :END:

*** EM

   #+BEGIN_SRC ipython
     def _nb_mix_llik(theta, x, s):
       """Return log likelihood matrix

       theta - array-like [2, k]
       x - array-like [n, 1]
       s - array-like [n, 1]

       """
       # Important: so.minimize flattens theta
       theta = theta.reshape(2, -1)
       mean = np.exp(theta[0]).reshape(1, -1)
       # Important: this can blow up
       inv_disp = np.exp(np.clip(theta[1], -15, 15)).reshape(1, -1)
       # [n, k]
       L = st.nbinom(n=inv_disp, p=1 / (1 + s * mean / inv_disp)).logpmf(x.reshape(-1, 1))
       assert L.shape == (x.shape[0], theta.shape[1])
       assert np.isfinite(L).all()
       return L

     def _nb_mix_obj(theta, x, z, s):
       """Return negative log likelihood

       theta - array-like [2, k]
       x - array-like [n, 1]
       z - array-like [n, k]
       s - array-like [n, 1]

       """
       L = _nb_mix_llik(theta, x, s)
       m = L.max(axis=1, keepdims=True)
       return -(np.log(z) + L).mean()

     def ebpm_gamma_mix(x, s, k, max_iters=100, tol=1e-3, verbose=False, seed=1):
       assert x.ndim == 2
       n, p = x.shape
       assert s.shape == (n, 1)
       assert k > 1
       rng = np.random.default_rng(seed)
       log_mean = rng.normal(size=(p, k))
       log_inv_disp = rng.normal(size=(p, k))
       z = np.ones((n, k)) / k
       loss = np.array([_nb_mix_obj(np.vstack([log_mean[j], log_inv_disp[j]]), x[:,j], z, s) for j in range(p)]).sum()
       if verbose:
         print(f'epoch 0: {loss:.4g}')
       for t in range(max_iters):
         for j in range(p):
           opt = so.minimize(_nb_mix_obj, x0=np.vstack([log_mean[j], log_inv_disp[j]]), args=(x[:,j], z, s), method='nelder-mead', options={'maxiter':1000})
           if not opt.success:
             raise RuntimeError(f'M step failed to converge: {opt.message}')
           log_mean[j] = opt.x[0]
           log_inv_disp[j] = opt.x[1]
         L = np.array([_nb_mix_llik(np.vstack(log_mean[j], log_inv_disp[j]), x[:,j], s) for j in range(p)]).sum(axis=0)
         z = sp.softmax(L, axis=1)
         update = np.array([_nb_mix_obj(np.vstack(log_mean[j], log_inv_disp[j]), x[:,j], z, s) for j in range(p)]).sum()
         if update > loss:
           raise RuntimeError('objective increased')
         elif loss - update < tol:
           return z, log_mean, log_inv_disp
         else:
           if verbose:
             print(f'epoch {t + 1}: {loss:.4g}')
           loss = update
       raise RuntimeError('failed to converge in max_iters')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[78]:
   :END:

*** MPEBPM

   First, start from the ground truth \(z\) (labels), and estimate the Gamma
   expression models.

   #+BEGIN_SRC ipython :async t
     fit0 = mpebpm.sgd.ebpm_gamma(
       temp.X,
       onehot=pd.get_dummies(temp.obs['cell_type']).values,
       batch_size=32,
       num_epochs=320,
       shuffle=True)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[52]:
   :END:

   Estimate the cluster weights.

   #+BEGIN_SRC ipython
     L = mpebpm.gam_mix._nb_mix_llik(
       x=torch.tensor(temp.X.A, dtype=torch.float), 
       s=torch.tensor(temp.X.sum(axis=1), dtype=torch.float),
       log_mean=torch.tensor(fit0[0], dtype=torch.float),
       log_inv_disp=torch.tensor(fit0[1], dtype=torch.float)).sum(dim=-1)
     zhat = torch.nn.functional.softmax(L, dim=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[114]:
   :END:

   Compute the cross entropy between the estimated \(\hat{z}\) and the ground
   truth.

   #+BEGIN_SRC ipython
     torch.nn.functional.binary_cross_entropy(
       zhat,
       torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[108]:
   : tensor(0.)
   :END:

   Compute a weighted log likelihood.

   #+BEGIN_SRC ipython
     w = torch.rand([512, 2])
     w /= w.sum(dim=1).unsqueeze(-1)
     m, _ = L.max(dim=1, keepdim=True)
     (m + torch.log(w * torch.exp(L - m) + 1e-8)).mean()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[159]:
   : tensor(-1872.6364)
   :END:

   Try fitting the model from a random initialization.

   #+BEGIN_SRC ipython :async t
     import imp; imp.reload(mpebpm.gam_mix)
     torch.manual_seed(1)
     fit = mpebpm.gam_mix.ebpm_gam_mix_em(
       x=temp.X.A,
       s=temp.X.sum(axis=1),
       y=torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float).cuda(),
       k=2,
       batch_size=512,
       num_epochs=400,
       max_em_iters=100,
       tol=0.1,
       log_dir='runs/nbmix/test11')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[21]:
   :END:

   Compute the cross entropy between the estimated \(\hat{z}\) and the ground
   truth.

   #+BEGIN_SRC ipython
     torch.nn.functional.binary_cross_entropy(
       torch.tensor(1 - fit[-1], dtype=torch.float),
       torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   : tensor(0.)
   :END:

   Plot the UMAP, colored by the fitted clusters.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/sim-ex-fit.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i in range(fit[-1].shape[1]):
       plt.plot(*temp[fit[-1][:,i].astype(bool)].obsm["X_umap"].T, c=cm(i), marker='.', ms=2, lw=0, label=f'Cluster {i}')
     plt.legend(frameon=False, markerscale=4, handletextpad=0)
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[26]:
   [[file:figure/nbmix.org/sim-ex-fit.png]]
   :END:

*** Amortized inference

   Fit the amortized inference model, initializing \(\vmu, \vphi\) from the MLE
   starting from the ground-truth labels.

   #+BEGIN_SRC ipython :async t
     import imp; imp.reload(mpebpm.gam_mix)
     torch.manual_seed(1)
     fit = mpebpm.gam_mix.EBPMGammaMix(
       p=temp.shape[1],
       k=2,
       log_mean=fit0[0],
       log_inv_disp=fit0[1]).fit(
         x=temp.X.A,
         s=temp.X.sum(axis=1),
         y=pd.get_dummies(temp.obs['cell_type']).values,
         batch_size=32,
         shuffle=False,
         num_pretrain=10,
         num_epochs=10,
         log_dir='runs/nbmix/test')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[73]:
   :END:

* Related work

  scVI ([[https://dx.doi.org/10.1038/s41592-018-0229-2][Lopez et al. 2018]],
  [[https://www.biorxiv.org/content/10.1101/532895v2][Xu et al. 2020]])
  implements a related deep unsupervised (more precisely, semi-supervised)
  clustering model ([[https://arxiv.org/abs/1406.5298][Kingma et al. 2014]],
  [[https://arxiv.org/abs/1611.02648][Dilokthanakul et al. 2016]]).

  \begin{align}
    x_{i\cdot} \mid s_i, \lambda_{ij} &\sim \Pois(s_i \lambda_{ij})\\
    \ln s_i &\sim \N(\cdot)\\
    \lambda_{ij} \mid z_{i\cdot} &\sim \Gam(\phi_j^{-1}, (\mu_{\lambda}^{-1}(z_{i\cdot}))_j \phi_j^{-1})\\
    z_{i\cdot} \mid y_i, u_i &\sim \N(\mu_i(u_i, y_i), \sigma^2(u_i, y_i))\\
    y_i &\sim \Mult(1, \vpi)\\
    u_i &\sim \N(0, \mi).
  \end{align}

  where

  - \(y_i\) denotes the cluster assignment for cell \(i\)
  - \(\mu_i(\cdot), \sigma^2(\cdot)\) are neural networks mapping the latent
    cluster variable \(y_i\) and Gaussian noise \(u_i\) to the latent variable
    \(z_i\)
  - \(\mu_{\lambda}(\cdot)\) is a neural network mapping latent variable \(z_i\) to
    latent gene expression \(\lambda_{ij}\)

  The intuition behind this model is that the prior \(p(z_i)\) (marginalizing
  over \(y_i\)) is a mixture of Gaussians, and therefore the model embeds
  examples in a space which makes clustering easy, and maps examples to those
  clusters simultaneously. To perform variational inference in this model,
  Lopez et al. introduce inference networks

  \begin{align}
    q(y_i, z_{i\cdot} \mid x_{i\cdot}) = q(z_{i\cdot} \mid x_{i\cdot})\, q(y_i \mid z_{i\cdot})
  \end{align}

  Rui Shu [[http://ruishu.io/2016/12/25/gmvae/][proposed an alternative
  generative model]], which has some practical benefits and can be adapted to
  this problem

  \begin{align}
    x_{i\cdot} \mid x_{i+}, \lambda_{ij} &\sim \Pois(x_{i+} \lambda_{ij})\\
    \lambda_{ij} \mid z_{i\cdot} &\sim \Gam(\phi_j^{-1}, (\mu_{\lambda}^{-1}(z_{i\cdot}))_j \phi_j^{-1})\\
    z_{i\cdot} \mid y_i &\sim \N(\mu_i(y_i), \sigma^2(y_i))\\
    y_i &\sim \Mult(1, \vpi)\\
    q(y_i, z_{i\cdot} \mid x_{i\cdot}) &= q(y_i \mid x_{i\cdot})\, q(z_i \mid y_i, x_{i\cdot})
  \end{align}
