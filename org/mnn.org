#+TITLE: Mutual nearest neighbors in topic model space
#+SETUPFILE: setup.org

* Introduction

  [[https://www.ncbi.nlm.nih.gov/pubmed/29608177][Haghverdi et al 2018]] introduce a method for batch correction based on
  identifying /mutual nearest neighbors/. The key idea of the method is to
  identify cells which should have "equal gene expression" across batches, and
  compute correction factors based on the observed differences in gene
  expression, where "difference" is cosine distance. The key intuition of the
  method is "Proper removal of the batch effect should result in the formation
  of...clusters, one for each cell type, where each cluster contains a mixture
  of cells from both batches."

  #+BEGIN_QUOTE
  Our use of MNN pairs involves three assumptions: (i) there is at least one
  cell population that is present in both batches, (ii) the batch effect is
  almost orthogonal to the biological subspace, and (iii) batch effect
  variation is much smaller than the biological effect variation between
  different cell types
  #+END_QUOTE

  Here, we first investigate the intuition and assumptions underlying MNN
  correction using real data with known, estimable batch effects (Sarkar et
  al. 2019). Then, we investigate using NMF/LDA to estimate true gene
  expression under the generative model

  \begin{align*}
    x_{ij} \mid s_i, \lambda_{ij} &\sim \operatorname{Poisson}(s_i \lambda_{ij})\\
    \lambda_{ij} &= \sum_{k=1}^K l_{ik} f_{jk}
  \end{align*}

  and compare MNN applied to this latent space against previous approaches
  based on cosine distance on normalized counts, or Euclidean distance in a
  principal component subspace.

* Setup
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="singlecell",partition="gpu2",opts="--gres=gpu:1",memory="16G") :exports none :dir /scratch/midway2/aksarkar/singlecell

  #+RESULTS:
  : Submitted batch job 743010

  #+BEGIN_SRC ipython
    import anndata
    import numpy as np
    import pandas as pd
    import scanpy as sc
    import sklearn.decomposition as skd
    import torch
    import torch.utils.data as td
    import torch.utils.tensorboard as tb
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[79]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[32]:
  :END:

  #+BEGIN_SRC ipython
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
    plt.rcParams['font.family'] = 'Nimbus Sans'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[33]:
  :END:

* Methods
** Fast approximate nearest neighbors

   - M. Aum√ºller, E. Bernhardsson, A. Faithfull: ANN-Benchmarks: A Benchmarking
     Tool for Approximate Nearest Neighbor Algorithms. Information
     Systems 2019. doi:10.1016/j.is.2019.02.006 https://github.com/erikbern/ann-benchmarks

** GMVAE

   [[http://ruishu.io/2016/12/25/gmvae/][GMVAE]] is a modification of the semi-supervised generative model first
   presented in Kingma & Welling 2014.

   #+BEGIN_SRC ipython
     def net(input_dim, hidden_dim):
       return torch.nn.Sequential(
         torch.nn.Linear(input_dim, hidden_dim),
         torch.nn.BatchNorm1d(hidden_dim),
         torch.nn.ReLU(),
         torch.nn.Linear(hidden_dim, hidden_dim),
         torch.nn.BatchNorm1d(hidden_dim),
         torch.nn.ReLU(),
       )  

     class VAE(torch.nn.Module):
       def __init__(self, input_dim, latent_dim, label_dim, hidden_dim=128):
         super().__init__()
         # q(z | x, y)
         self.qz = net(input_dim + label_dim, hidden_dim)
         self.qz_mean = torch.nn.Linear(hidden_dim, latent_dim)
         self.qz_scale = torch.nn.Sequential(torch.nn.Linear(hidden_dim, latent_dim), torch.nn.Softplus())
         # p(z | y)
         self.pz = net(label_dim, hidden_dim)
         self.pz_mean = torch.nn.Linear(hidden_dim, latent_dim)
         self.pz_scale = torch.nn.Sequential(torch.nn.Linear(hidden_dim, latent_dim), torch.nn.Softplus())
         # p(x | z)
         self.px = net(latent_dim, hidden_dim)
         self.px_lam = torch.nn.Sequential(torch.nn.Linear(hidden_dim, input_dim), torch.nn.Softplus())

         self.writer = tb.SummaryWriter()

       def forward(self, s, x, y, n_samples, global_step):
         # [batch_size, input_dim + label_dim]
         h = self.qz(torch.cat([x, y], dim=1))
         # [batch_size, latent_dim]
         mean = self.qz_mean(h)
         scale = self.qz_scale(h)
         # [n_samples, batch_size, latent_dim]
         qz = torch.distributions.Normal(mean, scale).rsample(n_samples)

         h = self.pz(y)
         prior_mean = self.pz_mean(h)
         prior_scale = self.pz_scale(h)
         # [n_samples,]
         kl = torch.sum(.5 * (1 + 2 * torch.log(scale / prior_scale) + ((prior_mean - mean) ** 2 + prior_scale - scale) / scale), axis=1)
         self.writer.add_scalar('loss/kl', kl.sum(), global_step)

         lam = self.px_lam(self.px(qz.reshape([-1, qz.shape[2]]))).reshape([qz.shape[0], qz.shape[1], -1])
         s = torch.reshape(s, [1, -1, 1])
         # [n_samples,]
         err = torch.mean(torch.sum(x * torch.log(s * lam) - s * lam + torch.lgamma(x + 1), dim=2), dim=0)
         self.writer.add_scalar('loss/err', err.sum(), global_step)
         loss = -torch.sum(err - kl)
         self.writer.add_scalar('loss/elbo', loss, global_step)
         assert not torch.isnan(loss)
         return loss

       def fit(self, data, n_epochs, n_samples=10, **kwargs):
         assert torch.cuda.is_available()
         self.cuda()
         n_samples = torch.Size([n_samples])
         opt = torch.optim.RMSprop(self.parameters(), **kwargs)
         global_step = 0
         for epoch in range(n_epochs):
           for s, x, y in data:
             s = s.cuda()
             x = x.cuda()
             y = y.cuda()
             opt.zero_grad()
             loss = self.forward(s, x, y, n_samples=n_samples, global_step=global_step)
             if torch.isnan(loss):
               raise RuntimeError('nan loss')
             loss.backward()
             opt.step()
             global_step += 1
         return self

       @torch.no_grad()
       def latent(self, data):
         res = []
         for s, x, y in data:
           s = s.cuda()
           x = x.cuda()
           y = y.cuda()
           res.append(self.qz_mean(self.qz(torch.cat([x, y], dim=1))).cpu().numpy())
         res = np.vstack(res)
         return res
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[151]:
   :END:

* Results
** iPSC data

   Load the iPSC data.

   #+BEGIN_SRC ipython :async t
     x = anndata.read_h5ad('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/ipsc/ipsc.h5ad')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[4]:
   :END:

   Take all cells from batch 1. A priori, there could be clusters by individual
   and plate.

   #+BEGIN_SRC ipython
     y = x[x.obs['batch'] == 'b1']
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[14]:
   :END:

   Use the default approach, projecting \(\ln(x+1)\) into a principal component
   subspace and computing nearest neighbors.

   #+BEGIN_SRC ipython :async t
     sc.pp.neighbors(y)
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-b1-umap.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     fig, ax = plt.subplots(1, 2)
     fig.set_size_inches(6, 3)
     for i, k in enumerate(y.obs['chip_id'].unique()):
       query = y[y.obs['chip_id'] == k].obsm['X_umap']
       ax[0].scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     ax[0].set_title('By donor')
     for i, k in enumerate(y.obs['experiment'].unique()):
       query = y[y.obs['experiment'] == k].obsm['X_umap']
       ax[1].scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     ax[1].set_title('By chip')
     for a in ax:
       a.set_xlabel('UMAP 1')
       a.set_ylabel('UMAP 2')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[49]:
   [[file:figure/mnn.org/ipsc-b1-umap.png]]
   :END:

   Take all cells from NA18507. A priori, there could be clusters by batch.

   #+BEGIN_SRC ipython :async t
     y = x[x.obs['chip_id'] == 'NA18507']
     sc.pp.neighbors(y)
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[50]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-NA18507-umap.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     fig, ax = plt.subplots(1, 2)
     fig.set_size_inches(6, 3)
     for i, k in enumerate(y.obs['batch'].unique()):
       query = y[y.obs['batch'] == k].obsm['X_umap']
       ax[0].scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     ax[0].set_title('By batch')
     for i, k in enumerate(y.obs['experiment'].unique()):
       query = y[y.obs['experiment'] == k].obsm['X_umap']
       ax[1].scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     ax[1].set_title('By chip')
     for a in ax:
       a.set_xlabel('UMAP 1')
       a.set_ylabel('UMAP 2')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[53]:
   [[file:figure/mnn.org/ipsc-NA18507-umap.png]]
   :END:

   Look at the all cells from all individuals measured in both batches 1 and 2.

   #+BEGIN_SRC ipython
     ix = set(x.obs.loc[x.obs['batch'] == 'b1','chip_id']) & set(x.obs.loc[x.obs['batch'] == 'b2','chip_id'])
     ix
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[61]:
   : {'NA18507', 'NA18508', 'NA19190'}
   :END:

   #+BEGIN_SRC ipython :async t
     y = x[x.obs['chip_id'].isin(ix)]
     sc.pp.neighbors(y)
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[63]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-b1-b2-umap.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     fig, ax = plt.subplots(1, 2)
     fig.set_size_inches(6, 3)
     for i, k in enumerate(y.obs['batch'].unique()):
       query = y[y.obs['batch'] == k].obsm['X_umap']
       ax[0].scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     ax[0].set_title('By batch')
     for i, k in enumerate(y.obs['chip_id'].unique()):
       query = y[y.obs['chip_id'] == k].obsm['X_umap']
       ax[1].scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     ax[1].set_title('By individual')
     for a in ax:
       a.set_xlabel('UMAP 1')
       a.set_ylabel('UMAP 2')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[64]:
   [[file:figure/mnn.org/ipsc-b1-b2-umap.png]]
   :END:

   Plot the full data, colored by batch.

   #+BEGIN_SRC ipython :async t
     sc.pp.neighbors(x)
     sc.tl.umap(x, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[65]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-umap.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, k in enumerate(x.obs['batch'].unique()):
       query = x[x.obs['batch'] == k].obsm['X_umap']
       plt.scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     plt.title('By batch')
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[74]:
   [[file:figure/mnn.org/ipsc-umap.png]]
   :END:

** iPSC Drop-Seq data

   Is it the case that Fluidigm C1 batch effects are really smaller? Try
   looking at scRNA-seq of iPSCs generated using Drop-Seq (Selewa et al. 2019).

   #+BEGIN_SRC ipython :async t
     x = anndata.read_h5ad('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/czi/drop/czi-ipsc-cm.h5ad')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   :END:

   Project \(\ln(x+1)\) into a principal component subspace and compute
   nearest neighbors.

   #+BEGIN_SRC ipython :async t
     y = x[x.obs['day'] == 0]
     sc.pp.filter_genes(y, min_cells=1)
     sc.pp.neighbors(y)
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[7]:
   :END:

   Plot the UMAP embedding of the principal component subspace.

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-cm-day0-umap.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, k in enumerate(y.obs['ind'].unique()):
       query = y[y.obs['ind'] == k].obsm['X_umap']
       plt.scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k)
     plt.legend(markerscale=8, handletextpad=0, frameon=False)
     plt.title('By donor')
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[24]:
   [[file:figure/mnn.org/ipsc-cm-day0-umap.png]]
   :END:

   Fit GMVAE.

   # https://discuss.pytorch.org/t/how-to-prefetch-data-when-processing-with-gpu/548/19

   #+BEGIN_SRC ipython :async t
     s = y.X.sum(axis=1)
     rep = pd.get_dummies(y.obs['ind'])
     dataset = td.TensorDataset(
       torch.tensor(s.A.ravel(), device='cuda:0'),
       torch.tensor(y.X.A, device='cuda:0'),
       torch.tensor(rep.values, dtype=torch.float, device='cuda:0'))
     data = td.DataLoader(dataset, batch_size=64, shuffle=True)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[9]:
   :END:

   #+BEGIN_SRC ipython :async t
     fit = VAE(input_dim=y.shape[1], latent_dim=10, label_dim=2).fit(data, n_epochs=10, lr=1e-2)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[119]:
   :END:

   Estimate the GMVAE latent variables \(E[\mathbf{z}_i \mid \mathbf{x}_i
   y_i]\), then compute a UMAP embedding of the latent space.

   #+BEGIN_SRC ipython :async t
     y.obsm['gmvae'] = fit.latent(data)
     sc.pp.neighbors(y, use_rep='gmvae')
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[129]:
   :END:

   Plot the UMAP embedding.

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/gmvae-umap.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, k in enumerate(y.obs['ind'].unique()):
       query = y[y.obs['ind'] == k].obsm['gmvae']
       plt.scatter(query[:,0], query[:,1], s=1, c=cm(i), label=k, zorder=-i)
     plt.legend(markerscale=8, handletextpad=0, frameon=False)
     plt.title('By donor')
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[138]:
   [[file:figure/mnn.org/gmvae-umap.png]]
   :END:

   Now, look at fitting a GMVAE for multiple days and replicates.

   #+BEGIN_SRC ipython :async t
     y = x[x.obs['day'].isin([0, 3])]
     sc.pp.filter_genes(y, min_cells=1)
     sc.pp.neighbors(y)
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[172]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-cm-day0-3.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     plt.gcf().set_size_inches(3.5, 2.5)
     for i, (d, k) in enumerate(y.obs.groupby(['day', 'ind']).groups.keys()):
       query = y[np.logical_and(y.obs['day'] == d, y.obs['ind'] == k)].obsm['X_umap']
       plt.scatter(query[:,0], query[:,1], s=1, c=np.array(cm(i)).reshape(1, -1), label=f'Day {d}/{k}', alpha=0.1)
     leg = plt.legend(markerscale=4, handletextpad=0, frameon=False, loc='center left', bbox_to_anchor=(1, .5))
     for h in leg.legendHandles:
       h.set_alpha(1)
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[183]:
   [[file:figure/mnn.org/ipsc-cm-day0-3.png]]
   :END:

   #+BEGIN_SRC ipython :async t
     s = y.X.sum(axis=1)
     rep = pd.get_dummies(y.obs['ind'])
     dataset = td.TensorDataset(
       torch.tensor(s.A.ravel()),
       torch.tensor(y.X.A),
       torch.tensor(rep.values, dtype=torch.float))
     data = td.DataLoader(dataset, batch_size=64, shuffle=True, num_workers=1)
     fit = VAE(input_dim=y.shape[1], latent_dim=10, label_dim=2).fit(data, n_epochs=10, lr=1e-2)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[156]:
   :END:

   #+BEGIN_SRC ipython :async t
     y.obsm['gmvae'] = fit.latent(td.DataLoader(dataset, batch_size=64, shuffle=False, num_workers=1))
     sc.pp.neighbors(y, use_rep='gmvae')
     sc.tl.umap(y, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[168]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/mnn.org/ipsc-cm-day0-3-gmvae.png
     cm = plt.get_cmap('Paired')
     plt.clf()
     plt.gcf().set_size_inches(3.75, 2.5)
     for i, (d, k) in enumerate(y.obs.groupby(['day', 'ind']).groups.keys()):
       query = y[np.logical_and(y.obs['day'] == d, y.obs['ind'] == k)].obsm['gmvae']
       plt.scatter(query[:,0], query[:,1], s=1, c=cm(i), label=f'Day {d}/{k}', alpha=0.5)
     plt.legend(markerscale=4, handletextpad=0, frameon=False, loc='center left', bbox_to_anchor=(1, .5))
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[169]:
   [[file:figure/mnn.org/ipsc-cm-day0-3-gmvae.png]]
   :END:

** NMF

   Instead of PCA, use NMF and normalize to a topic model as the latent space.

   #+BEGIN_SRC ipython :async t
     m = skd.NMF(n_components=10, solver='mu', beta_loss=1, max_iter=1000, verbose=True)
     l = m.fit_transform(x.X)
     f = m.components_
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[5]:
   :END:

   #+BEGIN_SRC ipython
     weights = l * f.sum(axis=1)
     topics = f.T / f.sum(axis=1)
     s = weights.sum(axis=1, keepdims=True)
     weights /= s
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   :END:

   #+BEGIN_SRC ipython
     x.obs['topic_scale'] = s
     x.obsm['topics'] = weights
     x.varm['topics'] = topics
     x.write('/project2/mstephens/aksarkar/projects/singlecell-ideas/data/ipsc/ipsc.h5ad')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[19]:
   :END:

   *TODO:* this segfaults.

   #+BEGIN_SRC ipython :async t
     sc.pp.neighbors(x, use_rep='topics')
     sc.tl.umap(x, copy=False)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   0 - 36d6e328-d507-454e-9ac5-657bf63ae113
   :END:
