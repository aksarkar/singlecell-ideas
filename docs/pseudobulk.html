<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-06-09 Tue 01:58 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Alternative approaches to scRNA-seq pseudobulk models</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="bootstrap.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="htmlize.css"/>
<link rel="stylesheet" type="text/css" href="main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Alternative approaches to scRNA-seq pseudobulk models</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#method">Method</a></li>
<li><a href="#data">Data</a></li>
<li><a href="#org1ee740f">Results</a>
<ul>
<li><a href="#orgda6373f">Comparison of mean estimates under different expression models</a></li>
<li><a href="#pseudobulk">Existing approach</a></li>
<li><a href="#ebpm">Homoscedastic approach</a></li>
<li><a href="#org218b466">Heteroscedastic approach</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org5c1ef8a" class="outline-2">
<h2 id="introduction"><a id="org5c1ef8a"></a>Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
One strategy for simplifying the analysis of scRNA-seq data is to construct
<i>pseudo-bulk data</i>. If we have molecule counts generated using scRNA-seq for
genes \(j = 1, \ldots, p\) measured in cells \(i = 1, \ldots, n\), belonging
to \(m\) different groups denoted by indicator variables \(z_{ik}, k = 1,
  \ldots, m\), then this approach constructs new data \(y_{kj} = \sum_i x_{ij}
  z_{ik}\). The key idea of this approach is that the new data \(y_{kj}\) can
be treated as bulk RNA-seq data in downstream analysis. This approach can be
justified as the MLE of the model \(
  \DeclareMathOperator\Gam{Gamma}
  \DeclareMathOperator\Poi{Poisson}
  \DeclareMathOperator\argmin{arg min}
  \DeclareMathOperator\digamma{\psi}
  \DeclareMathOperator\trigamma{\psi^{(1)}}
  \newcommand\mf{\mathbf{F}} 
  \newcommand\ml{\mathbf{L}}
  \newcommand\mx{\mathbf{X}}
  \newcommand\vb{\mathbf{b}}
  \newcommand\vc{\mathbf{c}}
  \newcommand\vl{\mathbf{l}}
  \newcommand\vmu{\boldsymbol{\mu}}
  \newcommand\vx{\mathbf{x}}
  \newcommand\xiplus{x_{i+}}
  \)
</p>

\begin{align}
  x_{ij} \mid \xiplus, \mu_{kj}, z_{ik} = 1 &\sim \Poi(\xiplus \mu_{kj})\\
  \hat{\mu}_{kj} &= \frac{\sum_i x_{ij} z_{ik}}{\sum_i \xiplus z_{ik}}.
\end{align}

<p>
However, this approach has been observed (by Luis Barreiro&rsquo;s lab) to lead to
biases in regression and differential expression analyses, possibly due to
widely varying size factors (total number of molecules observed). Here, we
investigate this bias, and outline alternative procedures which are not
biased by variation in size factors.
</p>
</div>
</div>

<div id="outline-container-orgbe5e71a" class="outline-2">
<h2 id="setup"><a id="orgbe5e71a"></a>Setup</h2>
<div class="outline-text-2" id="text-setup">
<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> anndata
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> mpebpm
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> scipy.sparse <span class="org-keyword">as</span> ss
<span class="org-keyword">import</span> scipy.stats <span class="org-keyword">as</span> st
<span class="org-keyword">import</span> sqlite3
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
%config <span class="org-variable-name">InlineBackend.figure_formats</span> = <span class="org-builtin">set</span>([<span class="org-string">'retina'</span>])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'figure.facecolor'</span>] = <span class="org-string">'w'</span>
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'font.family'</span>] = <span class="org-string">'Nimbus Sans'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge7fa045" class="outline-2">
<h2 id="method"><a id="orge7fa045"></a>Method</h2>
<div class="outline-text-2" id="text-method">
<p>
We assume (<a href="https://dx.doi.org/10.1371/journal.pgen.1008045">Sarkar et
 al. 2019</a>)
</p>

\begin{align*}
  x_{ij} \mid \xiplus, \lambda_{ij} &\sim \Poi(\xiplus \lambda_{ij})\\
  \lambda_{ij} \mid \mu_{ij}, \phi_{ij}, \pi_{ij} &\sim \pi_{ij} \delta_0(\cdot) + (1 - \pi_{ij}) \Gam(\phi_{ij}^{-1}, \mu_{ij}^{-1} \phi_{ij}^{-1})\\
  \ln \mu_{ij} &= (\ml \mf_\mu')_{ij}\\
  \ln \phi_{ij} &= (\ml \mf_\phi')_{ij}\\
  \operatorname{logit} \pi_{ij} &= (\ml \mf_\pi')_{ij},
\end{align*}

<p>
where 
</p>

<ul class="org-ul">
<li>\(x_{ij}\) is the number of molecules of gene \(j = 1, \ldots, p\) observed
in cell \(i = 1, \ldots, n\)</li>
<li>\(\xiplus \triangleq \sum_j x_{ij}\) is the total number of molecules
observed in sample \(i\)</li>
<li>cells are taken from \(m\) conditions, \(\ml\) is \(n \times m\),
and each \(\mf_{(\cdot)}\) is \(p \times m\)</li>
<li>assignments of cells to conditions (loadings) \(l_{ik} \in \{0, 1\}, k = 1,
    \ldots, m\) are known and fixed.</li>
</ul>

<p>
Under this model, latent gene expression \(\lambda_{ij} \sim g_{ij}(\cdot)\),
and e.g., the mean gene expression is
</p>

<p>
\[ E[\lambda_{ij} \mid \hat{g}] = (1 - \hat\pi_{ij}) \hat\mu_{ij}. \]
</p>

<p>
We fit the model by maximizing the likelihood using
<a href="mpebpm.html">stochastic gradient descent</a>.
</p>
</div>
</div>

<div id="outline-container-orgb3893e5" class="outline-2">
<h2 id="data"><a id="orgb3893e5"></a>Data</h2>
<div class="outline-text-2" id="text-data">
<p>
Read the iPSC data
(<a href="https://dx.doi.org/10.1371/journal.pgen.1008045">Sarkar et
al. 2019</a>). We generated scRNA-seq data for 5,597 induced pluripotent stem
cells derived from 54 donor individuals at 9,957 genes (after quality
control) using the Fludigm C1 platform.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">dat</span> = anndata.read_h5ad(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/ipsc/ipsc.h5ad'</span>)
</pre>
</div>

<p>
Construct pseudobulk data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">y</span> = pd.get_dummies(dat.obs[<span class="org-string">'chip_id'</span>]).values.T @ dat.X
</pre>
</div>

<p>
Plot the distribution of size factors for the pseudobulk data.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.hist(y.<span class="org-builtin">sum</span>(axis=1).ravel(), bins=12, color=<span class="org-string">'0.7'</span>)
plt.xlabel(<span class="org-string">'Size factor'</span>)
plt.ylabel(<span class="org-string">'Number of conditions'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/size.png" alt="size.png">
</p>
</div>

<p>
Prepare the data for <code>mpebpm</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">s</span> = dat.obs[<span class="org-string">'mol_hs'</span>].values.reshape(-1, 1)
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: constructing this as a dense matrix will blow up memory for larger</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">data sets</span>
<span class="org-variable-name">onehot</span> = ss.coo_matrix((np.ones(dat.shape[0]), (np.arange(dat.shape[0]), pd.Categorical(dat.obs[<span class="org-string">'chip_id'</span>]).codes))).tocsr()
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: center the matrix of dummy variables (batch), because there is no</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">baseline</span>
<span class="org-variable-name">design</span> = ss.coo_matrix(pd.get_dummies(dat.obs[<span class="org-string">'experiment'</span>])).astype(<span class="org-builtin">float</span>).A
<span class="org-variable-name">design</span> -= design.mean(axis=0)
</pre>
</div>

<p>
<i>SKP1</i> was the top eQTL in this data (refer to the
<a href="http://shiny.stephenslab.uchicago.edu:5007/qtls">browser</a>). Extract the
genotypes at the top cis-SNP for this gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> sqlite3.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/browser/browser.db'</span>) <span class="org-keyword">as</span> con:
  <span class="org-variable-name">query</span> = pd.read_sql(<span class="org-string">'select ind, value from mean_qtl_geno, qtls where mean_qtl_geno.gene == qtls.gene and qtls.name == "SKP1";'</span>, con=con)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ee740f" class="outline-2">
<h2 id="org1ee740f">Results</h2>
<div class="outline-text-2" id="text-org1ee740f">
</div>
<div id="outline-container-orgda6373f" class="outline-3">
<h3 id="orgda6373f">Comparison of mean estimates under different expression models</h3>
<div class="outline-text-3" id="text-orgda6373f">
<p>
As a preliminary investigation, compare estimates of the mean gene
expression under different model assumptions. Pseudobulk approaches are
justified as fitting a simple point mass expression model. However, in the
iPSC data, there are cell-specific technical covariates \(\vc_i\) whose
effect on each gene \(\vb_j\) needs to be estimated. This requires a
(slightly) more sophisticated approach
</p>

\begin{equation}
  x_{ij} \mid \xiplus, \mu_j, \vc_i, \vb_j \sim \Poi(\xiplus \exp(\vc_i' \vb_j) \mu_j)
\end{equation}

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu0</span>, <span class="org-variable-name">bhat0</span> = mpebpm.sgd.ebpm_point(
  dat.X.A,
  s=s,
  onehot=onehot,
  design=design,
  batch_size=64,
  shuffle=<span class="org-constant">True</span>,
  lr=1e-2,
  num_epochs=40,
  log_dir=f<span class="org-string">'runs/mpebpm/ipsc/point/'</span>)
</pre>
</div>

<p>
A point mass expression model is unlikely to be supported by the data. Our
alternative assumes point-Gamma expression models, which are supported by
empirical data (Sarkar et al. 2019, Sarkar and Stephens 2020). Read the
<a href="mpebpm.html#ipsc">previously fitted models</a>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-log-mu.npy'</span>)
<span class="org-variable-name">neg_log_phi1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-neg-log-phi.npy'</span>)
<span class="org-variable-name">logodds1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-logodds.npy'</span>)
<span class="org-variable-name">bhat1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-bhat.npy'</span>)
</pre>
</div>

<p>
Compare different mean estimates against each other.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">naive</span> = np.delete((np.log(y + 1) - np.log(y.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>))), 1, axis=0)
<span class="org-variable-name">pois</span> = np.delete(log_mu0, 1, axis=0)
<span class="org-variable-name">pg</span> = -np.log1p(np.exp(logodds1)) + log_mu1
plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 2, sharex=<span class="org-constant">True</span>, sharey=<span class="org-constant">True</span>)
fig.set_size_inches(6, 6)
ax[0,0].scatter(temp.ravel(), pois.ravel(), c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
ax[0,0].set_ylabel(<span class="org-string">'Log point mass mean\n(confounder-corrected)'</span>)
ax[1,0].scatter(temp.ravel(), pg.ravel(), c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
ax[1,0].set_xlabel(<span class="org-string">'Log point mass mean (naive)'</span>)
ax[1,0].set_ylabel(<span class="org-string">'Log Point-Gamma mean'</span>)
ax[1,1].scatter(pois.ravel(), pg.ravel(), c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
ax[1,1].set_xlabel(<span class="org-string">'Log point mass mean\n(confounder-corrected)'</span>)
<span class="org-variable-name">lim</span> = [-20, -5]
<span class="org-keyword">for</span> a <span class="org-keyword">in</span> ax.ravel():
  <span class="org-keyword">if</span> a <span class="org-keyword">is</span> <span class="org-keyword">not</span> ax[0,1]:
    a.plot(lim, lim, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[0,1].set_axis_off()
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/naive-vs-point-vs-point-gamma.png" alt="naive-vs-point-vs-point-gamma.png">
</p>
</div>

<p>
Compare different choices of pseudocount in the naive pseudobulk estimates.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">pg</span> = -np.log1p(np.exp(logodds1)) + log_mu1
plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(1, 3)
fig.set_size_inches(7.5, 2.5)
ax[0].scatter(np.delete((np.log(y + 1) - np.log(y.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>))), 1, axis=0).ravel(), pg.ravel() , c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
ax[0].set_xlabel(<span class="org-string">'$\ln((y+1)/s)$'</span>)
ax[0].set_ylabel(<span class="org-string">'Log Point-Gamma mean'</span>)
ax[1].scatter(np.delete((np.log(y + 1e-4) - np.log(y.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>))), 1, axis=0).ravel(), pg.ravel(), c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
ax[1].set_xlabel(<span class="org-string">'$\ln((y+10^{-4})/s)$'</span>)
ax[2].scatter(np.delete((np.log(y / y.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>) + 1)), 1, axis=0).ravel(), pg.ravel(), c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
ax[2].set_xlabel(<span class="org-string">'$\ln((y/s) + 1)$'</span>)
<span class="org-variable-name">lim</span> = [-20, -5]
<span class="org-keyword">for</span> a <span class="org-keyword">in</span> ax.ravel():
  a.plot(lim, lim, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/pg-vs-point-pseudocount.png" alt="pg-vs-point-pseudocount.png">
</p>
</div>

<p>
Look at the distribution of relative differences between the naive estimate
of the point mass, and the estimate accounting for the effect of technical
covariates.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.hist((pois - naive).ravel(), bins=30, color=<span class="org-string">'0.7'</span>, density=<span class="org-constant">True</span>)
plt.axvline(x=np.median(pois - naive), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
plt.xlabel(<span class="org-string">'Log fold change'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/point-mass-rel-diff.png" alt="point-mass-rel-diff.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org169c7c9" class="outline-3">
<h3 id="pseudobulk"><a id="org169c7c9"></a>Existing approach</h3>
<div class="outline-text-3" id="text-pseudobulk">
<p>
Simulate a random Gaussian covariate, and fit a linear model regressing
\(\ln(y_{kj} / y_{k+} + 1)\) against the (null) covariate.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">rng</span> = np.random.default_rng(1)
<span class="org-variable-name">log1p_y</span> = np.log1p(y / y.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>))
<span class="org-variable-name">m</span> = log1p_y.mean(axis=0)
<span class="org-variable-name">log1p_y</span> -= m
<span class="org-variable-name">log1p_y</span> /= log1p_y.std(axis=0)
<span class="org-variable-name">n</span>, <span class="org-variable-name">p</span> = log1p_y.shape
<span class="org-variable-name">x</span> = rng.normal(size=n)
<span class="org-variable-name">x</span> -= x.mean()
<span class="org-variable-name">x</span> /= x.std()
<span class="org-variable-name">bhat</span> = []
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(p):
  <span class="org-variable-name">b</span> = x @ log1p_y[:,j] / (x.T @ x)
  bhat.append(b)
<span class="org-variable-name">bhat</span> = np.array(bhat)
</pre>
</div>

<p>
Plot the distribution of regression coefficients for equal-sized bins of
genes, ranked by mean log pseudobulk gene expression.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">n_bins</span> = 15
<span class="org-variable-name">temp</span> = bhat[np.argsort(m)]
plt.clf()
plt.gcf().set_size_inches(4, 3)
plt.boxplot(np.array_split(temp, 15), positions=<span class="org-builtin">range</span>(15), widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
plt.axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
plt.xticks(np.arange(n_bins))
plt.xlabel(<span class="org-string">'Mean log pseudobulk gene expression bin'</span>)
plt.ylabel(<span class="org-string">'Estimated effect size'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/null-covariate-effect-by-pseudobulk-mean-equal-bins.png" alt="null-covariate-effect-by-pseudobulk-mean-equal-bins.png">
</p>
</div>

<p>
Downsample the pseudobulk data to get more size factor variation. Generate a
null covariate which is correlated with the size factor, and regress each
gene against it.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">rng</span> = np.random.default_rng(1)
<span class="org-variable-name">prob</span> = rng.beta(a=.2, b=.2, size=(n, 1))
<span class="org-variable-name">ysub</span> = rng.binomial(n=y.astype(<span class="org-builtin">int</span>), p=prob).astype(<span class="org-builtin">float</span>)
<span class="org-variable-name">log1p_ysub</span> = np.log1p(ysub / ysub.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>))
<span class="org-variable-name">m</span> = log1p_ysub.mean(axis=0)
<span class="org-variable-name">log1p_ysub</span> -= m
<span class="org-variable-name">log1p_ysub</span> /= log1p_ysub.std(axis=0)
<span class="org-variable-name">x</span> = prob.copy().ravel()
<span class="org-variable-name">x</span> -= x.mean()
<span class="org-variable-name">x</span> /= x.std()
<span class="org-variable-name">x</span> += rng.normal(size=n)
<span class="org-variable-name">bhat</span> = []
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(log1p_ysub.shape[1]):
  <span class="org-variable-name">b</span> = x @ log1p_ysub[:,j] / (x.T @ x)
  bhat.append(b)
<span class="org-variable-name">bhat</span> = np.array(bhat)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">n_bins</span> = 15
<span class="org-variable-name">temp</span> = bhat[np.argsort(m)]
plt.clf()
plt.gcf().set_size_inches(4, 3)
plt.boxplot(np.array_split(temp, 15), positions=<span class="org-builtin">range</span>(15), widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
plt.axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
plt.xticks(np.arange(n_bins))
plt.xlabel(<span class="org-string">'Mean log pseudobulk gene expression bin'</span>)
plt.ylabel(<span class="org-string">'Estimated effect size'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/size-covariate-effect-by-pseudobulk-mean-equal-bins.png" alt="size-covariate-effect-by-pseudobulk-mean-equal-bins.png">
</p>
</div>

<p>
Repeat the analysis for the top <i>cis</i>-eQTL for <i>SKP1</i>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">design</span> = query[<span class="org-string">'value'</span>] - query[<span class="org-string">'value'</span>].mean()
<span class="org-variable-name">design</span> /= design.std()
<span class="org-variable-name">design.index</span> = query[<span class="org-string">'ind'</span>]
<span class="org-variable-name">response</span> = pd.DataFrame(log1p_y, index=dat.obs[<span class="org-string">'chip_id'</span>].unique(), columns=dat.var[<span class="org-string">'name'</span>])
<span class="org-variable-name">design</span>, <span class="org-variable-name">response</span> = design.align(response, join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">bhat</span> = []
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(p):
  <span class="org-variable-name">b</span> = design @ response.iloc[:,j] / (design.T @ design)
  bhat.append(b)
<span class="org-variable-name">bhat</span> = np.array(bhat)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">n_bins</span> = 15
<span class="org-variable-name">temp</span> = bhat[np.argsort(m)]
plt.clf()
plt.gcf().set_size_inches(4, 3)
plt.boxplot(np.array_split(temp, 15), positions=<span class="org-builtin">range</span>(15), widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
plt.axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
plt.xticks(np.arange(n_bins))
plt.xlabel(<span class="org-string">'Mean log pseudobulk gene expression bin'</span>)
plt.ylabel(<span class="org-string">'Estimated effect size'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/eqtl-effect-by-pseudobulk-mean-equal-bins.png" alt="eqtl-effect-by-pseudobulk-mean-equal-bins.png">
</p>
</div>

<p>
One potential explanation for these results is that \(\ln(y_{kj} / y_{k+} +
   1)\) is a biased estimator of \(\ln(\lambda_{kj} + 1)\), and the magnitude
of the bias depends on the true gene expression \(\lambda_{kj}\)
(<a href="https://www.biorxiv.org/content/early/2018/08/31/404962">Lun 2018</a>)
</p>

<p>
\[ E[\ln(y_{kj} / y_{k+} + 1)] \approx E[\ln(\lambda_{kj} + 1)] - \frac{V[y_{kj} / y_{k+}]}{2 (\lambda_{kj} + 1)^2}. \]
</p>
</div>
</div>

<div id="outline-container-org457c69e" class="outline-3">
<h3 id="ebpm"><a id="org457c69e"></a>Homoscedastic approach</h3>
<div class="outline-text-3" id="text-ebpm">
<p>
Read the <a href="mpebpm.html#ipsc">estimated model parameters</a>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-log-mu.npy'</span>)
<span class="org-variable-name">neg_log_phi</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-neg-log-phi.npy'</span>)
<span class="org-variable-name">logodds</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-logodds.npy'</span>)
</pre>
</div>

<p>
Estimate the mean latent gene expression \(E[\lambda_{ij}] = (1 - \pi_{ij})
   \mu_{ij}\).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">m</span>, <span class="org-variable-name">p</span> = log_mu.shape
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: log(sigmoid(x)) = -softplus(-x)</span>
<span class="org-variable-name">log_mean</span> = -np.log1p(np.exp(-logodds)) + log_mu
<span class="org-variable-name">y</span> = log_mean - log_mean.mean(axis=0)
<span class="org-variable-name">y</span> /= y.std(axis=0)
</pre>
</div>

<p>
Simulate a null covariate.
</p>

<div class="org-src-container">
<pre class="src src-ipython">np.random.seed(1)
<span class="org-variable-name">x</span> = np.random.normal(size=log_mean.shape[0])
<span class="org-variable-name">x</span> -= x.mean()
<span class="org-variable-name">x</span> /= x.std()
</pre>
</div>

<p>
For each gene, fit a linear model regressing mean latent gene expression in
each individual against the covariate.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">bhat</span> = []
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(p):
  <span class="org-variable-name">b</span> = x @ y[:,j] / (x.T @ x)
  bhat.append(b)
<span class="org-variable-name">bhat</span> = np.array(bhat)
</pre>
</div>

<p>
Plot the distribution of regression coefficients, binned by the mean latent
gene expression over all cells. Assuming
</p>

<p>
\[ x_{ij} \mid \xiplus, \mu_j \sim \Poi(\xiplus \mu_j), \]
</p>

<p>
it is straightforward to show
</p>

<p>
\[ \hat{\mu_j} = \frac{\sum_i x_{ij}}{\sum_i \xiplus}. \]
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">global_log_mean</span> = np.log(dat.X.<span class="org-builtin">sum</span>(axis=0) / dat.X.<span class="org-builtin">sum</span>()).ravel()
<span class="org-variable-name">grid</span> = np.linspace(global_log_mean.<span class="org-builtin">min</span>(), global_log_mean.<span class="org-builtin">max</span>(), 15)
<span class="org-variable-name">bins</span> = np.digitize(global_log_mean, grid).ravel()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 1, sharex=<span class="org-constant">True</span>)
fig.set_size_inches(5.5, 4)
ax[0].bar(<span class="org-builtin">range</span>(grid.shape[0] - 1), [(bins == i).<span class="org-builtin">sum</span>() <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, grid.shape[0])], align=<span class="org-string">'edge'</span>, width=1, color=<span class="org-string">'k'</span>)
ax[0].set_ylabel(<span class="org-string">'Number of genes'</span>)
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, grid.shape[0]):
  ax[1].boxplot(bhat[bins == i], positions=[i - .5], widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
ax[1].axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
ax[1].set_xticks(np.arange(grid.shape[0]))
ax[1].set_xticklabels([f<span class="org-string">'{g:.3g}'</span> <span class="org-keyword">for</span> g <span class="org-keyword">in</span> grid], rotation=90)
ax[1].set_xlabel(<span class="org-string">'Mean latent gene expression'</span>)
ax[1].set_ylabel(<span class="org-string">'Estimated effect size'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/null-covariate-effect-by-mean.png" alt="null-covariate-effect-by-mean.png">
</p>
</div>

<p>
Plot the distribution of regression coefficients for equal-sized bins of
genes, ranked by global mean latent gene expression.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">n_bins</span> = 15
<span class="org-variable-name">temp</span> = bhat[np.argsort(global_log_mean.A.ravel())]
plt.clf()
plt.gcf().set_size_inches(4, 3)
plt.boxplot(np.array_split(temp, 15), positions=<span class="org-builtin">range</span>(15), widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
plt.axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
plt.xticks(np.arange(n_bins))
plt.xlabel(<span class="org-string">'Mean latent gene expression bin'</span>)
plt.ylabel(<span class="org-string">'Estimated effect size'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/null-covariate-effect-by-mean-equal-bins.png" alt="null-covariate-effect-by-mean-equal-bins.png">
</p>
</div>

<p>
For each gene, fit a linear model regressing mean latent gene expression on
genotype at the cis-SNP.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">design</span> = query[<span class="org-string">'value'</span>] - query[<span class="org-string">'value'</span>].mean()
<span class="org-variable-name">design</span> /= design.std()
<span class="org-variable-name">design.index</span> = query[<span class="org-string">'ind'</span>]
<span class="org-variable-name">response</span> = pd.DataFrame(y, index=dat.obs[<span class="org-string">'chip_id'</span>].unique(), columns=dat.var[<span class="org-string">'name'</span>])
<span class="org-variable-name">design</span>, <span class="org-variable-name">response</span> = design.align(response, join=<span class="org-string">'inner'</span>)
<span class="org-variable-name">bhat</span> = []
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(p):
  <span class="org-variable-name">b</span> = design @ response.iloc[:,j] / (design.T @ design)
  bhat.append(b)
<span class="org-variable-name">bhat</span> = np.array(bhat)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 1, sharex=<span class="org-constant">True</span>)
fig.set_size_inches(5.5, 4)
ax[0].bar(<span class="org-builtin">range</span>(grid.shape[0] - 1), [(bins == i).<span class="org-builtin">sum</span>() <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, grid.shape[0])], align=<span class="org-string">'edge'</span>, width=1, color=<span class="org-string">'k'</span>)
ax[0].set_ylabel(<span class="org-string">'Number of genes'</span>)
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1, grid.shape[0]):
  ax[1].boxplot(bhat[bins == i], positions=[i - .5], widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
ax[1].axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
ax[1].set_xticks(np.arange(grid.shape[0]))
ax[1].set_xticklabels([f<span class="org-string">'{g:.3g}'</span> <span class="org-keyword">for</span> g <span class="org-keyword">in</span> grid], rotation=90)
ax[1].set_xlabel(<span class="org-string">'Mean latent gene expression'</span>)
ax[1].set_ylabel(<span class="org-string">'Estimated effect size'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/eqtl-effect-by-mean.png" alt="eqtl-effect-by-mean.png">
</p>
</div>

<p>
Report the global mean gene expression of <i>SKP1</i> (marking which gene
expression bin it fell into).
</p>

<div class="org-src-container">
<pre class="src src-ipython">pd.Series(global_log_mean.A.ravel(), index=response.columns).loc[<span class="org-string">'SKP1'</span>]
</pre>
</div>

<pre class="example">
-6.9060464

</pre>

<p>
After centering and scaling the data, the sampling variance of the
regression coefficient should be \(1 / 53\). Compare the standard deviation
of the estimated \(\hat{b_1}, \ldots, \hat{b_p}\) to this theoretical
expectation.
</p>

<div class="org-src-container">
<pre class="src src-ipython">pd.Series({
  <span class="org-string">'theoretical'</span>: np.sqrt(1 / 53),
  <span class="org-string">'empirical'</span>: bhat.std()
})
</pre>
</div>

<pre class="example">
theoretical    0.137361
empirical      0.136828
dtype: float64
</pre>

<p>
Plot the distribution of regression coefficients for equal-sized bins of
genes, ranked by global mean latent gene expression.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">n_bins</span> = 15
<span class="org-variable-name">temp</span> = bhat[np.argsort(global_log_mean.A.ravel())]
plt.clf()
plt.gcf().set_size_inches(4, 3)
plt.boxplot(np.array_split(temp, 15), positions=<span class="org-builtin">range</span>(15), widths=.5, flierprops={<span class="org-string">'markersize'</span>: 1}, medianprops={<span class="org-string">'color'</span>: <span class="org-string">'k'</span>})
plt.axhline(y=0, lw=1, ls=<span class="org-string">'--'</span>, c=<span class="org-string">'k'</span>)
plt.xticks(np.arange(n_bins))
plt.xlabel(<span class="org-string">'Mean latent gene expression bin'</span>)
plt.ylabel(<span class="org-string">'Estimated effect size'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/eqtl-effect-by-mean-equal-bins.png" alt="eqtl-effect-by-mean-equal-bins.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org218b466" class="outline-3">
<h3 id="org218b466">Heteroscedastic approach</h3>
<div class="outline-text-3" id="text-org218b466">
<p>
The motivation behind limma-voom (Law et al. 2014) is: (1) to use a
transform \(\ln(y_{kj} / y_{k+} + \epsilon)\) as an estimate of the log of
true gene expression, and (2) to produce an estimate of uncertainty for each
observation. As discussed above, in scRNA-seq analysis, (1) is justified
under a point mass expression model. To achieve (2), Law et al. 2014 use a
non-parametric regression to predict \(V[\ln(y_{kj} / y_{k+} + \epsilon)]\)
from \(\ln(y_{kj} / y_{k+} + \epsilon)\), because there is no information in
bulk RNA-seq data which could be used to estimate a variance. However, that
is no longer true for scRNA-seq data, for which there are (at least) two
possibilities for a precision weight derived from fitted expression models:
</p>

<ol class="org-ol">
<li><b>point mass:</b> the standard error of the estimated mean</li>
<li><b>(point-)Gamma:</b> the estimated variance</li>
</ol>

<p>
Choice (1) is analytic:
</p>

\begin{align}
  \ell &\triangleq \sum_i \ln p(x_{ij} \mid \xiplus, \mu_j) = \sum_i x_{ij} \ln(\xiplus \mu_j) - \xiplus \mu_j + \mathrm{const}\\
  \frac{\partial \ell}{\partial \mu_j} &= \sum_i \frac{x_{ij}}{\mu_j} - \xiplus\\
  \frac{\partial^2 \ell}{\partial \mu_j^2} &= -\sum_i \frac{x_{ij}}{\mu_j^2}\\
  \mathcal{I}(\mu_j) &= -E\left[\frac{\partial^2 \ell}{\partial \mu_j^2}\right] = \frac{E[\sum_i \xiplus]}{\mu_j^2} = \frac{\sum_i \xiplus}{\mu_j}\\
  s_j^2 &= \frac{\mu_j}{\sum_i \xiplus},
\end{align}

<p>
where we have used the fact that \(\sum_i x_{ij} \sim \Poi(\mu_j \sum_i
   \xiplus)\). The standard error remains unchanged even after introducing
multiplicative effects for observed technical covariates. As a sanity check,
the standard error decreases as the total sequencing depth increases, and
increases as the estimated mean increases (consistent with higher
variability in higher expressed genes). As an example, plot the bootstrap
distribution of the estimated mean against the analytic SE for a simple
simulation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">rng</span> = np.random.default_rng(1)
<span class="org-variable-name">n_trials</span> = 500
<span class="org-variable-name">n</span> = 100
<span class="org-variable-name">s</span> = 1e4
<span class="org-variable-name">log_mu</span> = -10
<span class="org-variable-name">muhat</span> = []
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_trials):
  <span class="org-variable-name">x</span> = rng.poisson(s * np.exp(log_mu), size=n)
  muhat.append(x.<span class="org-builtin">sum</span>() / (n * s))
<span class="org-variable-name">muhat</span> = np.array(muhat)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.hist(muhat, bins=16, density=<span class="org-constant">True</span>, color=<span class="org-string">'0.7'</span>)
<span class="org-variable-name">grid</span> = np.linspace(muhat.<span class="org-builtin">min</span>(), muhat.<span class="org-builtin">max</span>(), 1000)
plt.plot(grid, st.norm(loc=muhat.mean(), scale=np.sqrt(muhat[0] / (n * s))).pdf(grid), lw=1, c=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'Est mean gene expression'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/pseudobulk.org/analytic-se.png" alt="analytic-se.png">
</p>
</div>

<p>
Choice (2) is also analytic, e.g., assuming a Gamma expression model
</p>

\begin{align}
  \lambda_{ij} &\sim \Gam(\phi_j^{-1}, \mu_j^{-1} \phi_j^{-1})\\
  E[\ln \lambda_{ij}] &= \digamma(\phi_j^{-1}) + \ln(\mu_j \phi_j)\\
  V[\ln \lambda_{ij}] &= \trigamma(\phi_j^{-1}),
\end{align}

<p>
where the Gamma distribution is parameterized by shape and rate,
\(\digamma(\cdot)\) denotes the digamma function, and \(\trigamma(\cdot)\)
denotes the trigamma function. However, we previously noted that robustly
estimating \(\phi_j\) is difficult, even from hundreds of cells per
condition.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2020-06-09 Tue 01:58</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
