<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-05-14 Thu 13:29 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Massively Parallel Empirical Bayes Poisson Means</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="bootstrap.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="htmlize.css"/>
<link rel="stylesheet" type="text/css" href="main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Massively Parallel Empirical Bayes Poisson Means</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#results">Results</a>
<ul>
<li><a href="#accuracy">Accuracy of parameter estimation</a></li>
<li><a href="#gof">Goodness of fit</a></li>
<li><a href="#ipsc">Application to iPSCs</a></li>
<li><a href="#confounders">Confounder correction in iPSC data</a></li>
<li><a href="#org49570ac">Variance within versus between individuals in iPSC data</a></li>
<li><a href="#immune-census">Application to Census of Immune Cells</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org62be355" class="outline-2">
<h2 id="introduction"><a id="org62be355"></a>Introduction</h2>
<div class="outline-text-2" id="text-introduction">
<p>
The <i>Empirical Bayes Poisson Means</i> (EBPM) problem is \( 
  \DeclareMathOperator\Gam{Gamma}
  \DeclareMathOperator\Poi{Poisson}
  \DeclareMathOperator\argmin{arg min}
  \newcommand\mf{\mathbf{F}} 
  \newcommand\ml{\mathbf{L}}
  \newcommand\mx{\mathbf{X}}
  \newcommand\vl{\mathbf{l}}
  \newcommand\vx{\mathbf{x}}
  \)
</p>

\begin{align*}
  x_i \mid s_i, \lambda_i &\sim \Poi(s_i \lambda_i)\\
  \lambda_i &\sim g(\cdot) \in \mathcal{G},
\end{align*}

<p>
where the (primary) inference goal is to estimate \(g\) by maximizing the
likelihood. In our prior work
(<a href="https://dx.doi.org/10.1371/journal.pgen.1008045">Sarkar et al. 2019</a>), we
used this approach to estimate the mean and variance of gene expression from
scRNA-seq data collected on a homogeneous sample of cells from each of a
number of donor individuals, where we assumed \(\mathcal{G}\) was the family
of point-Gamma distributions. This procedure removes the effect of variation
introduced by the measurement process, leaving the variation in true gene
expression levels which are of interest
(<a href="http://dx.doi.org/10.1101/2020.04.07.030007">Sarkar and Stephens
2020</a>). In total, we solved 537,678 EBPM problems in parallel by formulating
them as a single factor model
</p>

\begin{align*}
  x_{ij} \mid x_{i+}, \lambda_{ij} &\sim \Poi(x_{i+} \lambda_{ij})\\
  \lambda_{ij} \mid \mu_{ij}, \phi_{ij}, \pi_{ij} &\sim \pi_{ij} \delta_0(\cdot) + (1 - \pi_{ij}) \Gam(\phi_{ij}^{-1}, \mu_{ij}^{-1} \phi_{ij}^{-1})\\
  \ln \mu_{ij} &= (\ml \mf_\mu')_{ij}\\
  \ln \phi_{ij} &= (\ml \mf_\phi')_{ij}\\
  \operatorname{logit} \pi_{ij} &= (\ml \mf_\pi')_{ij},
\end{align*}

<p>
where 
</p>

<ul class="org-ul">
<li>\(x_{ij}\) is the number of molecules of gene \(j = 1, \ldots, p\) observed
in cell \(i = 1, \ldots, n\)</li>
<li>\(x_{i+} \triangleq \sum_j x_{ij}\) is the total number of molecules
observed in sample \(i\)</li>
<li>cells are taken from \(m\) donor individuals, \(\ml\) is \(n \times m\),
and each \(\mf_{(\cdot)}\) is \(p \times m\)</li>
<li>assignments of cells to donors (loadings) \(l_{ik} \in \{0, 1\}, k = 1,
    \ldots, m\) are known and fixed.</li>
</ul>

<p>
We previously implemented maximum likelihood inference of this model via
batch gradient descent in the Python package
<a href="https://www.github.com/aksarkar/scqtl.git">scqtl</a>. We have now developed a
new Python package <a href="https://www.github.com/aksarkar/mpebpm.git">mpebpm</a>,
which scales to much larger data sets. The key improvements are optimization
using minibatch gradient descent and support for sparse matrices. Here, we
evaluate the method on simulations and large biological data sets.
</p>
</div>
</div>

<div id="outline-container-org9626900" class="outline-2">
<h2 id="setup"><a id="org9626900"></a>Setup</h2>
<div class="outline-text-2" id="text-setup">
<pre class="example">
Submitted batch job 1331143

</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> anndata
<span class="org-keyword">import</span> loompy
<span class="org-keyword">import</span> mpebpm
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> os
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> scipy.sparse <span class="org-keyword">as</span> ss
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> scipy.stats <span class="org-keyword">as</span> st
<span class="org-keyword">import</span> scmodes
<span class="org-keyword">import</span> scqtl
<span class="org-keyword">import</span> time
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
%config <span class="org-variable-name">InlineBackend.figure_formats</span> = <span class="org-builtin">set</span>([<span class="org-string">'retina'</span>])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'figure.facecolor'</span>] = <span class="org-string">'w'</span>
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'font.family'</span>] = <span class="org-string">'Nimbus Sans'</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">srun --pty --partition=mstephens bash
<span class="org-builtin">source</span> activate singlecell
tensorboard --host=$(<span class="org-sh-quoted-exec">hostname</span> -i) --logdir=runs &amp;
</pre>
</div>
</div>
</div>

<div id="outline-container-orge80a058" class="outline-2">
<h2 id="results"><a id="orge80a058"></a>Results</h2>
<div class="outline-text-2" id="text-results">
</div>
<div id="outline-container-orgd051fd5" class="outline-3">
<h3 id="accuracy"><a id="orgd051fd5"></a>Accuracy of parameter estimation</h3>
<div class="outline-text-3" id="text-accuracy">
<p>
We previously evaluated <code>scqtl</code>
<a href="https://jdblischak.github.io/singlecell-qtl/zinb.html#orgca44e7f">by
simulating data from the model</a>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">def</span> <span class="org-function-name">evaluate</span>(num_samples, num_mols, num_trials=10, **kwargs):
  <span class="org-comment-delimiter"># </span><span class="org-comment">Important: generate all of the samples for each trial in one shot, and use</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">one-hot encoding to get separate estimates</span>
  <span class="org-variable-name">args</span> = [(num_samples * num_trials, num_mols, log_mu, log_phi, logodds, <span class="org-constant">None</span>, <span class="org-constant">None</span>, <span class="org-constant">None</span>)
          <span class="org-keyword">for</span> log_mu <span class="org-keyword">in</span> np.linspace(-12, -6, 7)
          <span class="org-keyword">for</span> log_phi <span class="org-keyword">in</span> np.linspace(-4, 0, 5)
          <span class="org-keyword">for</span> logodds <span class="org-keyword">in</span> np.linspace(-3, 3, 7)]
  <span class="org-variable-name">x</span> = np.concatenate([scqtl.simulation.simulate(*a)[0][:,:1] <span class="org-keyword">for</span> a <span class="org-keyword">in</span> args], axis=1)
  <span class="org-variable-name">x</span> = ss.csr_matrix(x)
  <span class="org-variable-name">s</span> = num_mols * np.ones((x.shape[0], 1))
  <span class="org-variable-name">onehot</span> = np.zeros((num_samples * num_trials, num_trials))
  onehot[np.arange(onehot.shape[0]), np.arange(onehot.shape[0]) // num_samples] = 1
  <span class="org-variable-name">onehot</span> = ss.csr_matrix(onehot)

  <span class="org-variable-name">log_mu</span>, <span class="org-variable-name">neg_log_phi</span>, <span class="org-variable-name">logodds</span> = mpebpm.sgd.ebpm_point_gamma(x, s=s, onehot=onehot, **kwargs)
  <span class="org-variable-name">result</span> = pd.DataFrame(
    [(a[0] // num_trials, <span class="org-builtin">int</span>(a[1]), <span class="org-builtin">int</span>(a[2]), <span class="org-builtin">int</span>(a[3]), <span class="org-builtin">int</span>(a[4]), a[-1], trial)
     <span class="org-keyword">for</span> a <span class="org-keyword">in</span> args
     <span class="org-keyword">for</span> trial <span class="org-keyword">in</span> <span class="org-builtin">range</span>(num_trials)],
    columns=[<span class="org-string">'num_samples'</span>, <span class="org-string">'num_mols'</span>, <span class="org-string">'log_mu'</span>, <span class="org-string">'log_phi'</span>, <span class="org-string">'logodds'</span>, <span class="org-string">'fold'</span>, <span class="org-string">'trial'</span>])
  <span class="org-variable-name">result</span>[<span class="org-string">'mean'</span>] = np.exp(result[<span class="org-string">'log_mu'</span>])
  <span class="org-variable-name">result</span>[<span class="org-string">'var'</span>] = (1 - sp.expit(result[<span class="org-string">'logodds'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu'</span>] + result[<span class="org-string">'log_phi'</span>]) + sp.expit(-result[<span class="org-string">'logodds'</span>]) * (1 - sp.expit(result[<span class="org-string">'logodds'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu'</span>])

  <span class="org-variable-name">result</span>[<span class="org-string">'log_mu_hat'</span>] = log_mu.ravel(order=<span class="org-string">'F'</span>)
  <span class="org-variable-name">result</span>[<span class="org-string">'log_phi_hat'</span>] = -neg_log_phi.ravel(order=<span class="org-string">'F'</span>)
  <span class="org-variable-name">result</span>[<span class="org-string">'logodds_hat'</span>] = logodds.ravel(order=<span class="org-string">'F'</span>)
  <span class="org-variable-name">result</span>[<span class="org-string">'mean_hat'</span>] = np.exp(result[<span class="org-string">'log_mu_hat'</span>])
  <span class="org-variable-name">result</span>[<span class="org-string">'var_hat'</span>] = (1 - sp.expit(result[<span class="org-string">'logodds_hat'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu_hat'</span>] + result[<span class="org-string">'log_phi_hat'</span>]) + sp.expit(-result[<span class="org-string">'logodds_hat'</span>]) * (1 - sp.expit(result[<span class="org-string">'logodds_hat'</span>])) * np.exp(2 * result[<span class="org-string">'log_mu_hat'</span>])

  <span class="org-variable-name">diagnostic</span> = []
  <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(x.shape[1]):
    <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(onehot.shape[1]):
      <span class="org-variable-name">idx</span> = onehot.A[:,j].astype(<span class="org-builtin">bool</span>)
      diagnostic.append(scqtl.diagnostic.diagnostic_test(
        x.A[idx,i].reshape(-1, 1),
        log_mu[j,i],
        -neg_log_phi[j,i],
        -logodds[j,i],
        num_mols,
        np.ones((num_samples, 1))))
  <span class="org-variable-name">diagnostic</span> = np.array(diagnostic)
  <span class="org-variable-name">result</span>[<span class="org-string">'ks_d'</span>] = diagnostic[:,0]
  <span class="org-variable-name">result</span>[<span class="org-string">'ks_p'</span>] = diagnostic[:,1]
  <span class="org-keyword">return</span> result
</pre>
</div>

<p>
Run the simulation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = [evaluate(num_samples=num_samples,
                   num_mols=<span class="org-builtin">int</span>(1e5),
                   batch_size=32,
                   num_epochs=num_epochs,
                   log_dir=f<span class="org-string">'runs/mpebpm/sim-{num_samples}/'</span>)
          <span class="org-comment-delimiter"># </span><span class="org-comment">Important: for fixed batch size, having more samples means more</span>
          <span class="org-comment-delimiter"># </span><span class="org-comment">updates to each parameter per epoch</span>
          <span class="org-keyword">for</span> num_samples, num_epochs <span class="org-keyword">in</span> <span class="org-builtin">zip</span>((100, 1000), (200, 20))]
pd.concat(result).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-sim.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Read the results.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-sim.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
</pre>
</div>

<p>
Plot the estimated values against the ground truth values.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">samples_pass</span> = result[<span class="org-string">'num_samples'</span>] == 100
<span class="org-variable-name">mu_pass</span> = result[<span class="org-string">'log_mu'</span>] &gt; -10
<span class="org-variable-name">pi_pass</span> = result[<span class="org-string">'logodds'</span>] &lt; 0

plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 3)
fig.set_size_inches(8, 5)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and(pi_pass, samples_pass)]
ax[0, 0].scatter(subset[<span class="org-string">'log_mu'</span>], subset[<span class="org-string">'log_mu_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 0].set_xlim(-14, -5)
ax[0, 0].set_ylim(ax[0, 0].get_xlim())
ax[0, 0].plot(ax[0, 0].get_xlim(), ax[0, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 0].set_xlabel(<span class="org-string">'True $\ln(\mu)$'</span>)
ax[0, 0].set_ylabel(<span class="org-string">'Estimated $\ln(\mu)$'</span>)

ax[1, 0].set_xscale(<span class="org-string">'log'</span>)
ax[1, 0].set_yscale(<span class="org-string">'log'</span>)
ax[1, 0].scatter(subset[<span class="org-string">'mean'</span>], subset[<span class="org-string">'mean_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 0].set_xlim(1e-6, 1e-2)
ax[1, 0].set_ylim(ax[1, 0].get_xlim())
ax[1, 0].plot(ax[1, 0].get_xlim(), ax[1, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 0].set_xlabel(<span class="org-string">'True latent mean'</span>)
ax[1, 0].set_ylabel(<span class="org-string">'Estimated latent mean'</span>)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and.<span class="org-builtin">reduce</span>(np.vstack([samples_pass, mu_pass, pi_pass]))]
ax[0, 1].scatter(subset[<span class="org-string">'log_phi'</span>], subset[<span class="org-string">'log_phi_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 1].set_xlim(-5, 2)
ax[0, 1].set_ylim(ax[0, 1].get_xlim())
ax[0, 1].plot(ax[0, 1].get_xlim(), ax[0, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 1].set_xlabel(<span class="org-string">'True $\ln(\phi)$'</span>)
ax[0, 1].set_ylabel(<span class="org-string">'Estimated $\ln(\phi)$'</span>)

ax[1, 1].set_xscale(<span class="org-string">'log'</span>)
ax[1, 1].set_yscale(<span class="org-string">'log'</span>)
ax[1, 1].scatter(subset[<span class="org-string">'var'</span>], subset[<span class="org-string">'var_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 1].set_xlim(1e-9, 5e-5)
ax[1, 1].set_ylim(ax[1, 1].get_xlim())
ax[1, 1].plot(ax[1, 1].get_xlim(), ax[1, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 1].set_xlabel(<span class="org-string">'True latent variance'</span>)
ax[1, 1].set_ylabel(<span class="org-string">'Estimated latent variance'</span>)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and(pi_pass, samples_pass)]
ax[0, 2].scatter(subset[<span class="org-string">'logodds'</span>], subset[<span class="org-string">'logodds_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 2].plot(ax[0, 2].get_xlim(), ax[0, 2].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 2].set_xlabel(<span class="org-string">'True $\mathrm{logit}(\pi)$'</span>)
ax[0, 2].set_ylabel(<span class="org-string">'Estimated $\mathrm{logit}(\pi)$'</span>)

ax[1, 2].set_axis_off()
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/sim-params.png" alt="sim-params.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">samples_pass</span> = result[<span class="org-string">'num_samples'</span>] == 1000
<span class="org-variable-name">mu_pass</span> = result[<span class="org-string">'log_mu'</span>] &gt; -10
<span class="org-variable-name">pi_pass</span> = result[<span class="org-string">'logodds'</span>] &lt; 0

plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 3)
fig.set_size_inches(8, 5)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and(pi_pass, samples_pass)]
ax[0, 0].scatter(subset[<span class="org-string">'log_mu'</span>], subset[<span class="org-string">'log_mu_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 0].set_xlim(-14, -5)
ax[0, 0].set_ylim(ax[0, 0].get_xlim())
ax[0, 0].plot(ax[0, 0].get_xlim(), ax[0, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 0].set_xlabel(<span class="org-string">'True $\ln(\mu)$'</span>)
ax[0, 0].set_ylabel(<span class="org-string">'Estimated $\ln(\mu)$'</span>)

ax[1, 0].set_xscale(<span class="org-string">'log'</span>)
ax[1, 0].set_yscale(<span class="org-string">'log'</span>)
ax[1, 0].scatter(subset[<span class="org-string">'mean'</span>], subset[<span class="org-string">'mean_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 0].set_xlim(1e-6, 1e-2)
ax[1, 0].set_ylim(ax[1, 0].get_xlim())
ax[1, 0].plot(ax[1, 0].get_xlim(), ax[1, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 0].set_xlabel(<span class="org-string">'True latent mean'</span>)
ax[1, 0].set_ylabel(<span class="org-string">'Estimated latent mean'</span>)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and.<span class="org-builtin">reduce</span>(np.vstack([samples_pass, mu_pass, pi_pass]))]
ax[0, 1].scatter(subset[<span class="org-string">'log_phi'</span>], subset[<span class="org-string">'log_phi_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 1].set_xlim(-5, 2)
ax[0, 1].set_ylim(ax[0, 1].get_xlim())
ax[0, 1].plot(ax[0, 1].get_xlim(), ax[0, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 1].set_xlabel(<span class="org-string">'True $\ln(\phi)$'</span>)
ax[0, 1].set_ylabel(<span class="org-string">'Estimated $\ln(\phi)$'</span>)

ax[1, 1].set_xscale(<span class="org-string">'log'</span>)
ax[1, 1].set_yscale(<span class="org-string">'log'</span>)
ax[1, 1].scatter(subset[<span class="org-string">'var'</span>], subset[<span class="org-string">'var_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 1].set_xlim(1e-9, 5e-5)
ax[1, 1].set_ylim(ax[1, 1].get_xlim())
ax[1, 1].plot(ax[1, 1].get_xlim(), ax[1, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 1].set_xlabel(<span class="org-string">'True latent variance'</span>)
ax[1, 1].set_ylabel(<span class="org-string">'Estimated latent variance'</span>)

<span class="org-variable-name">subset</span> = result.loc[np.logical_and(pi_pass, samples_pass)]
ax[0, 2].scatter(subset[<span class="org-string">'logodds'</span>], subset[<span class="org-string">'logodds_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 2].plot(ax[0, 2].get_xlim(), ax[0, 2].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 2].set_xlabel(<span class="org-string">'True $\mathrm{logit}(\pi)$'</span>)
ax[0, 2].set_ylabel(<span class="org-string">'Estimated $\mathrm{logit}(\pi)$'</span>)

ax[1, 2].set_axis_off()
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/sim-1000-params.png" alt="sim-1000-params.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org753cc61" class="outline-3">
<h3 id="gof"><a id="org753cc61"></a>Goodness of fit</h3>
<div class="outline-text-3" id="text-gof">
<p>
We previously developed a test for goodness of fit, based on the fact that
if \(x_{ij} \sim F_{ij}\), then \(F_{ij}(x_{ij}) \sim
   \operatorname{Uniform}(0, 1)\). We applied this test to the distributions
estimated from the simulated data sets. Plot the histogram of
goodness-of-fit \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result.loc[result[<span class="org-string">'num_samples'</span>] == 100, <span class="org-string">'ks_p'</span>], bins=np.linspace(0, 1, 11), density=<span class="org-constant">True</span>, color=<span class="org-string">'0.7'</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlim(0, 1)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-sim-gof.png" alt="mpebpm-sim-gof.png">
</p>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result.loc[result[<span class="org-string">'num_samples'</span>] == 1000, <span class="org-string">'ks_p'</span>], bins=np.linspace(0, 1, 11), density=<span class="org-constant">True</span>, color=<span class="org-string">'0.7'</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlim(0, 1)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-sim-1000-gof.png" alt="mpebpm-sim-1000-gof.png">
</p>
</div>

<p>
Report the number (proportion) of simulation trials where the observed data
significantly depart from the estimated distribution (\(p < 0.05\) after
Bonferroni correction).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sig</span> = result.groupby(<span class="org-string">'num_samples'</span>).<span class="org-builtin">apply</span>(<span class="org-keyword">lambda</span> x: x.loc[x[<span class="org-string">'ks_p'</span>] &lt; 0.05 / x.shape[0]]).reset_index(drop=<span class="org-constant">True</span>)
sig.groupby(<span class="org-string">'num_samples'</span>)[<span class="org-string">'ks_p'</span>].agg(<span class="org-builtin">len</span>)
</pre>
</div>

<pre class="example">
num_samples
1000    21.0
Name: ks_p, dtype: float64
</pre>

<p>
Plot the estimated and ground truth parameters for trials where the data
departed from the estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">samples_pass</span> = sig[<span class="org-string">'num_samples'</span>] == 1000
<span class="org-variable-name">mu_pass</span> = sig[<span class="org-string">'log_mu'</span>] &gt; -10
<span class="org-variable-name">pi_pass</span> = sig[<span class="org-string">'logodds'</span>] &lt; 0

plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 3)
fig.set_size_inches(8, 5)

<span class="org-variable-name">subset</span> = sig.loc[np.logical_and(pi_pass, samples_pass)]
ax[0, 0].scatter(subset[<span class="org-string">'log_mu'</span>], subset[<span class="org-string">'log_mu_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 0].set_xlim(-14, -5)
ax[0, 0].set_ylim(ax[0, 0].get_xlim())
ax[0, 0].plot(ax[0, 0].get_xlim(), ax[0, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 0].set_xlabel(<span class="org-string">'True $\ln(\mu)$'</span>)
ax[0, 0].set_ylabel(<span class="org-string">'Estimated $\ln(\mu)$'</span>)

ax[1, 0].set_xscale(<span class="org-string">'log'</span>)
ax[1, 0].set_yscale(<span class="org-string">'log'</span>)
ax[1, 0].scatter(subset[<span class="org-string">'mean'</span>], subset[<span class="org-string">'mean_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 0].set_xlim(1e-6, 1e-2)
ax[1, 0].set_ylim(ax[1, 0].get_xlim())
ax[1, 0].plot(ax[1, 0].get_xlim(), ax[1, 0].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 0].set_xlabel(<span class="org-string">'True latent mean'</span>)
ax[1, 0].set_ylabel(<span class="org-string">'Estimated latent mean'</span>)

<span class="org-variable-name">subset</span> = sig.loc[np.logical_and.<span class="org-builtin">reduce</span>(np.vstack([samples_pass, mu_pass, pi_pass]))]
ax[0, 1].scatter(subset[<span class="org-string">'log_phi'</span>], subset[<span class="org-string">'log_phi_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 1].set_xlim(-5, 2)
ax[0, 1].set_ylim(ax[0, 1].get_xlim())
ax[0, 1].plot(ax[0, 1].get_xlim(), ax[0, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 1].set_xlabel(<span class="org-string">'True $\ln(\phi)$'</span>)
ax[0, 1].set_ylabel(<span class="org-string">'Estimated $\ln(\phi)$'</span>)

ax[1, 1].set_xscale(<span class="org-string">'log'</span>)
ax[1, 1].set_yscale(<span class="org-string">'log'</span>)
ax[1, 1].scatter(subset[<span class="org-string">'var'</span>], subset[<span class="org-string">'var_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[1, 1].set_xlim(1e-9, 5e-5)
ax[1, 1].set_ylim(ax[1, 1].get_xlim())
ax[1, 1].plot(ax[1, 1].get_xlim(), ax[1, 1].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[1, 1].set_xlabel(<span class="org-string">'True latent variance'</span>)
ax[1, 1].set_ylabel(<span class="org-string">'Estimated latent variance'</span>)

<span class="org-variable-name">subset</span> = sig.loc[np.logical_and(pi_pass, samples_pass)]
ax[0, 2].scatter(subset[<span class="org-string">'logodds'</span>], subset[<span class="org-string">'logodds_hat'</span>], s=2, c=<span class="org-string">'k'</span>)
ax[0, 2].plot(ax[0, 2].get_xlim(), ax[0, 2].get_xlim(), c=<span class="org-string">'r'</span>, ls=<span class="org-string">':'</span>, lw=1)
ax[0, 2].set_xlabel(<span class="org-string">'True $\mathrm{logit}(\pi)$'</span>)
ax[0, 2].set_ylabel(<span class="org-string">'Estimated $\mathrm{logit}(\pi)$'</span>)

ax[1, 2].set_axis_off()
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/sim-1000-params-sig.png" alt="sim-1000-params-sig.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org09c6f5e" class="outline-3">
<h3 id="ipsc"><a id="org09c6f5e"></a>Application to iPSCs</h3>
<div class="outline-text-3" id="text-ipsc">
<p>
We previously generated scRNA-seq of 5,597 cells from 54 donors
(<a href="https://dx.doi.org/10.1371/journal.pgen.1008045">Sarkar et
al. 2019</a>). Read the data, and remove the donor with evidence of
contamination.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">x</span> = anndata.read_h5ad(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/ipsc/ipsc.h5ad'</span>)
<span class="org-variable-name">x</span> = x[x.obs.chip_id != <span class="org-string">'NA18498'</span>]
x.X
</pre>
</div>

<pre class="example">
&lt;5578x9957 sparse matrix of type '&lt;class 'numpy.float32'&gt;'
with 39529537 stored elements in Compressed Sparse Row format&gt;
</pre>

<p>
Prepare the data.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-comment-delimiter"># </span><span class="org-comment">Important: the dense data will fit on the GPU</span>
<span class="org-variable-name">y</span> = x.X.A
<span class="org-variable-name">s</span> = x.obs[<span class="org-string">'mol_hs'</span>].values.reshape(-1, 1)
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: constructing this as a dense matrix will blow up memory for larger</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">data sets</span>
<span class="org-variable-name">onehot</span> = ss.coo_matrix((np.ones(x.shape[0]), (np.arange(x.shape[0]), pd.Categorical(x.obs[<span class="org-string">'chip_id'</span>]).codes))).tocsr()
<span class="org-comment-delimiter"># </span><span class="org-comment">Important: center the matrix of dummy variables (batch), because there is no</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">baseline</span>
<span class="org-variable-name">design</span> = ss.coo_matrix(pd.get_dummies(x.obs[<span class="org-string">'experiment'</span>])).astype(<span class="org-builtin">float</span>).A
<span class="org-variable-name">design</span> -= design.mean(axis=0)
</pre>
</div>

<p>
Fit <code>mpebpm</code> (41 s to initialize; 39 s to fit).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">trial</span> = 5
<span class="org-variable-name">num_epochs</span> = 40
<span class="org-variable-name">batch_size</span> = 64
<span class="org-variable-name">lr</span> = 1e-2
<span class="org-variable-name">res1</span> = mpebpm.sgd.ebpm_gamma(
  y,
  s=s,
  onehot=onehot,
  batch_size=batch_size,
  shuffle=<span class="org-constant">True</span>,
  lr=lr,
  num_epochs=num_epochs,
  log_dir=f<span class="org-string">'runs/mpebpm/ipsc{trial}/init/'</span>)
<span class="org-variable-name">log_mu</span>, <span class="org-variable-name">neg_log_phi</span>, <span class="org-variable-name">logodds</span> = mpebpm.sgd.ebpm_point_gamma(
  y,
  s=s,
  onehot=onehot,
  init=res1,
  batch_size=batch_size,
  shuffle=<span class="org-constant">True</span>,
  lr=lr,
  num_epochs=num_epochs,
  log_dir=f<span class="org-string">'runs/mpebpm/ipsc{trial}/fit/'</span>)
</pre>
</div>

<p>
Estimate log likelihood for each observation under Gamma and point-Gamma
expression models.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean</span> = s.ravel() * onehot @ np.exp(res1[0])
<span class="org-variable-name">inv_disp</span> = onehot @ np.exp(res1[1])
<span class="org-variable-name">nb_llik</span> = (y * np.log(mean / inv_disp)
           - y * np.log(1 + mean / inv_disp)
           - inv_disp * np.log(1 + mean / inv_disp)
           + sp.gammaln(y + inv_disp)
           - sp.gammaln(inv_disp)
           - sp.gammaln(y + 1))

<span class="org-variable-name">mean</span> = s.ravel() * onehot @ np.exp(log_mu)
<span class="org-variable-name">inv_disp</span> = onehot @ np.exp(neg_log_phi)
<span class="org-variable-name">temp</span> = (y * np.log(mean / inv_disp)
           - y * np.log(1 + mean / inv_disp)
           - inv_disp * np.log(1 + mean / inv_disp)
           + sp.gammaln(y + inv_disp)
           - sp.gammaln(inv_disp)
           - sp.gammaln(y + 1))
<span class="org-variable-name">case_zero</span> = -np.log1p(np.exp(onehot @ -logodds)) + np.log1p(np.exp(temp - (onehot @ logodds)))
<span class="org-variable-name">case_non_zero</span> = -np.log1p(np.exp(onehot @ logodds)) + temp
<span class="org-variable-name">zinb_llik</span> = np.where(y &lt; 1, case_zero, case_non_zero)
</pre>
</div>

<p>
Take the best model for each donor/gene combination, then evaluate the full
data log likelihood.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">L</span> = np.tensordot(onehot.T.A, np.stack([nb_llik, zinb_llik], axis=-1), 1)
L.<span class="org-builtin">max</span>(axis=-1).<span class="org-builtin">sum</span>() / np.prod(y.shape)
</pre>
</div>

<pre class="example">
-51.14861191512254

</pre>

<p>
Evaluate the proportion of times each model was the best fit for donor/gene
combinations.
</p>

<div class="org-src-container">
<pre class="src src-ipython">pd.Series({k: v <span class="org-keyword">for</span> k, v <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(
  [<span class="org-string">'gamma'</span>, <span class="org-string">'point_gamma'</span>],
  np.histogram(L.argmax(axis=-1), bins=np.arange(3))[0])}) / np.prod(L.shape[:2])
</pre>
</div>

<pre class="example">
gamma          0.311343
point_gamma    0.688657
dtype: float64
</pre>

<p>
Test each individual-gene combination for goodness-of-fit to the
<code>mpebpm</code>-estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = <span class="org-builtin">dict</span>()
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(x.shape[1]):
  <span class="org-keyword">for</span> k, donor <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(pd.Categorical(x.obs[<span class="org-string">'chip_id'</span>]).categories):
    <span class="org-variable-name">idx</span> = onehot[:,k].A.ravel().astype(<span class="org-builtin">bool</span>)
    <span class="org-variable-name">size</span> = s[idx].ravel()
    <span class="org-keyword">if</span> L[k,j,0] &gt; L[k,j,1]:
      <span class="org-variable-name">d</span>, <span class="org-variable-name">p</span> = scmodes.benchmark.gof._gof(
        y[idx,j],
        cdf=scmodes.benchmark.gof._zig_cdf,
        pmf=scmodes.benchmark.gof._zig_pmf,
        size=size,
        log_mu=res1[0][k,j],
        log_phi=-res1[1][k,j])
    <span class="org-keyword">else</span>:
      <span class="org-variable-name">d</span>, <span class="org-variable-name">p</span> = scmodes.benchmark.gof._gof(
        y[idx,j],
        cdf=scmodes.benchmark.gof._zig_cdf,
        pmf=scmodes.benchmark.gof._zig_pmf,
        size=size,
        log_mu=log_mu[k,j],
        log_phi=-neg_log_phi[k,j],
        logodds=logodds[k,j])
    result[(donor, x.var.iloc[j].name)] = pd.Series({<span class="org-string">'stat'</span>: d, <span class="org-string">'p'</span>: p})
<span class="org-variable-name">result</span> = pd.DataFrame.from_dict(result, orient=<span class="org-string">'index'</span>)
<span class="org-variable-name">result.index.names</span> = [<span class="org-string">'donor'</span>, <span class="org-string">'gene'</span>]
<span class="org-variable-name">result</span> = result.reset_index()
</pre>
</div>

<p>
Write out the GOF tests.
</p>

<div class="org-src-container">
<pre class="src src-ipython">result.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-gof.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Plot the histogram of GOF \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result[<span class="org-string">'p'</span>], bins=np.linspace(0, 1, 11), color=<span class="org-string">'0.7'</span>, density=<span class="org-constant">True</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlim(0, 1)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc-gof.png" alt="mpebpm-ipsc-gof.png">
</p>
</div>

<p>
Report how many individual-gene combinations (proportion) depart
significantly from the estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">sig</span> = result.loc[result[<span class="org-string">'p'</span>] &lt; 0.05 / result.shape[0]]
sig.shape[0], sig.shape[0] / result.shape[0]
</pre>
</div>

<pre class="example">
(65, 0.000123171145359006)

</pre>

<p>
Look at one of the examples where the data depart from the estimated
distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 1)
fig.set_size_inches(6, 4)
<span class="org-variable-name">query</span> = x[x.obs[<span class="org-string">'chip_id'</span>] == sig.iloc[0][<span class="org-string">'donor'</span>], x.var.index == sig.iloc[0][<span class="org-string">'gene'</span>]].X.A.ravel()
ax[0].hist(query, bins=np.arange(query.<span class="org-builtin">max</span>() + 1), color=<span class="org-string">'k'</span>)
ax[0].set_xlabel(<span class="org-string">'Number of molecules'</span>)
ax[0].set_ylabel(<span class="org-string">'Number of cells'</span>)
ax[0].set_title(x.var.loc[sig.iloc[0][<span class="org-string">'gene'</span>], <span class="org-string">'name'</span>])

<span class="org-variable-name">grid</span> = np.linspace(0, 1e-3, 1000)
<span class="org-variable-name">j</span> = <span class="org-builtin">list</span>(x.var.index).index(sig.iloc[0][<span class="org-string">'gene'</span>])
<span class="org-variable-name">k</span> = <span class="org-builtin">list</span>(pd.Categorical(x.obs[<span class="org-string">'chip_id'</span>]).categories).index(sig.iloc[0][<span class="org-string">'donor'</span>])
ax[1].plot(grid, st.gamma(a=np.exp(neg_log_phi[k,j]), scale=np.exp(log_mu[k,j] - neg_log_phi[k,j])).cdf(grid), c=<span class="org-string">'k'</span>, lw=1)
ax[1].set_xlabel(<span class="org-string">'Latent gene expression'</span>)
ax[1].set_ylabel(<span class="org-string">'CDF'</span>)

fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc-ex.png" alt="mpebpm-ipsc-ex.png">
</p>
</div>

<p>
Report all genes at which the data depart from the estimated distribution
for at least one individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython">x.var.merge(sig, left_index=<span class="org-constant">True</span>, right_on=<span class="org-string">'gene'</span>, how=<span class="org-string">'inner'</span>)[<span class="org-string">'name'</span>].unique()
</pre>
</div>

<pre class="example">
array(['NUP98', 'B4GALT5', 'ANXA5', 'RHOG', 'MT-CO2', 'MT-CYB', 'MT-ND2',
'MT-ND4', 'MT-ATP6', 'MT-CO3', 'MT-ND4L'], dtype=object)
</pre>
</div>
</div>

<div id="outline-container-org1a9953a" class="outline-3">
<h3 id="confounders"><a id="org1a9953a"></a>Confounder correction in iPSC data</h3>
<div class="outline-text-3" id="text-confounders">
<p>
Repeat the analysis, including C1 chip as a covariate (1.4 minutes init,
1.35 minutes fit).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">num_epochs</span> = 80
<span class="org-variable-name">init</span> = mpebpm.sgd.ebpm_gamma(
  y,
  s=s,
  onehot=onehot,
  design=design,
  batch_size=64,
  lr=1e-2,
  num_epochs=num_epochs,
  log_dir=<span class="org-string">'runs/mpebpm/ipsc/design2/init'</span>)
<span class="org-variable-name">log_mu1</span>, <span class="org-variable-name">neg_log_phi1</span>, <span class="org-variable-name">logodds1</span>, <span class="org-variable-name">bhat1</span> = mpebpm.sgd.ebpm_point_gamma(
  y,
  s=s,
  init=init[:-1],
  onehot=onehot,
  design=design,
  batch_size=64,
  lr=1e-2,
  num_epochs=num_epochs,
  log_dir=<span class="org-string">'runs/mpebpm/ipsc/design2/fit'</span>)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-log-mu'</span>, log_mu1)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-neg-log-phi'</span>, neg_log_phi1)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-logodds'</span>, logodds1)
np.save(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-bhat'</span>, bhat1)
</pre>
</div>

<p>
Read the <code>mpebpm</code> and <code>scqtl</code> estimates.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-log-mu.npy'</span>)
<span class="org-variable-name">neg_log_phi1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-neg-log-phi.npy'</span>)
<span class="org-variable-name">logodds1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-logodds.npy'</span>)
<span class="org-variable-name">bhat1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-bhat.npy'</span>)

<span class="org-variable-name">log_mu2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-mu.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">log_phi2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-log-phi.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">logodds2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/zi2-logodds.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
<span class="org-variable-name">bhat2</span> = pd.read_table(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-qtl/data/density-estimation/design1/beta.txt.gz'</span>, index_col=0, sep=<span class="org-string">' '</span>)
</pre>
</div>

<p>
Compare the <code>mpebpm</code> estimates with and without correcting for batch.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(1, 3)
fig.set_size_inches(7, 2.5)

ax[0].scatter(log_mu.ravel(), log_mu1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[0].set_xlim(ax[0].get_ylim())
ax[0].plot(ax[0].get_xlim(), ax[0].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[0].set_xlabel(<span class="org-string">'Est $\log(\mu)$'</span>)
ax[0].set_ylabel(<span class="org-string">'Corrected est $\log(\mu)$'</span>)

ax[1].scatter(-neg_log_phi.ravel(), -neg_log_phi1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[1].set_xlim(ax[1].get_ylim())
ax[1].plot(ax[1].get_xlim(), ax[1].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[1].set_xlabel(<span class="org-string">'Est $\log(\phi)$'</span>)
ax[1].set_ylabel(<span class="org-string">'Corrected est $\log(\phi)$'</span>)

ax[2].scatter(logodds.ravel(), logodds1.ravel(), s=1, c=<span class="org-string">'k'</span>, alpha=0.1)
ax[2].set_xlim(ax[2].get_ylim())
ax[2].plot(ax[2].get_xlim(), ax[2].get_ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
ax[2].set_xlabel(<span class="org-string">'Est $\mathrm{logit}(\pi)$'</span>)
ax[2].set_ylabel(<span class="org-string">'Corrected est $\mathrm{logit}(\pi)$'</span>)

fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-ipsc-design.png" alt="mpebpm-ipsc-design.png">
</p>
</div>

<p>
Compare the <code>mpebpm</code> estimated mean latent gene expression against the
<code>scqtl</code> estimate.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">mean1</span> = -np.log1p(np.exp(logodds1)) + log_mu1
<span class="org-variable-name">mean2</span> = -np.log1p(np.exp(logodds2)) + log_mu2
<span class="org-keyword">del</span> mean2[<span class="org-string">'NA18498'</span>]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.scatter(mean1.ravel(), mean2.values.ravel(order=<span class="org-string">'F'</span>), c=<span class="org-string">'k'</span>, s=1, alpha=0.1)
plt.xlim(plt.ylim())
plt.plot(plt.xlim(), plt.ylim(), lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'r'</span>)
plt.xlabel(<span class="org-string">'mpebpm log latent mean'</span>)
plt.ylabel(<span class="org-string">'scqtl log latent mean'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-scqtl-ipsc-latent-mean.png" alt="mpebpm-scqtl-ipsc-latent-mean.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org49570ac" class="outline-3">
<h3 id="org49570ac">Variance within versus between individuals in iPSC data</h3>
<div class="outline-text-3" id="text-org49570ac">
<p>
Read the estimated parameters.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-log-mu.npy'</span>)
<span class="org-variable-name">neg_log_phi1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-neg-log-phi.npy'</span>)
<span class="org-variable-name">logodds1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-logodds.npy'</span>)
<span class="org-variable-name">bhat1</span> = np.load(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-ipsc-design-bhat.npy'</span>)
</pre>
</div>

<p>
Estimate the latent mean and variance of gene expression for each
individual, for each gene.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mean</span> = -np.log1p(np.exp(-logodds1)) + log_mu1
<span class="org-comment-delimiter"># </span><span class="org-comment">V[lam] = (1 - pi) mu^2 phi + pi (1 - pi) mu^2</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">log(x + y) = log(x) + softplus(log y - log x)</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">log(sigmoid(x)) = -softplus(-x)</span>
<span class="org-variable-name">a</span> = -np.log1p(np.exp(-logodds1)) + 2 * log_mu1 - neg_log_phi1
<span class="org-variable-name">b</span> = -np.log1p(np.exp(-logodds1)) - np.log1p(np.exp(logodds1)) + 2 * log_mu1
<span class="org-variable-name">log_var</span> = a + np.log1p(np.exp(b - a))
</pre>
</div>

<p>
Plot the relationship between variance between individuals (sample variance
of latent mean gene expression values), and: (1) average gene expression,
and (2) average variance of latent gene expression within an individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(1, 2, sharey=<span class="org-constant">True</span>)
fig.set_size_inches(4.5, 2.5)
<span class="org-keyword">for</span> a <span class="org-keyword">in</span> ax.ravel():
  a.set_xscale(<span class="org-string">'log'</span>)
  a.set_yscale(<span class="org-string">'log'</span>)
  a.set_aspect(<span class="org-string">'equal'</span>, adjustable=<span class="org-string">'datalim'</span>)
ax[0].scatter(np.exp(log_mean).mean(axis=0), np.exp(log_mean).var(axis=0), c=<span class="org-string">'k'</span>, s=1,alpha=0.2)
ax[0].set_xlabel(<span class="org-string">'Mean latent gene expression'</span>)
ax[0].set_ylabel(<span class="org-string">'Between individual variance\nlatent gene expression'</span>)
ax[1].scatter(np.exp(log_var).mean(axis=0), np.exp(log_mean).var(axis=0), c=<span class="org-string">'k'</span>, s=1,alpha=0.2)
ax[1].set_xlabel(<span class="org-string">'Within individual variance\nlatent gene expression'</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/ipsc-var-between-var-within.png" alt="ipsc-var-between-var-within.png">
</p>
</div>

<p>
The distribution of variance between individuals appears to be bimodal. Look
at the genes in the lower mode.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">query</span> = np.exp(log_mean).var(axis=0) &lt; 1e-20
<span class="org-variable-name">temp</span> = x.var.loc[query].copy()
<span class="org-variable-name">temp</span>[<span class="org-string">'mean'</span>] = np.exp(log_mean).mean(axis=0)[query]
<span class="org-keyword">print</span>(temp.sort_values(<span class="org-string">'mean'</span>, ascending=<span class="org-constant">False</span>).head(n=20).to_html(classes=<span class="org-string">'table'</span>))
</pre>
</div>

<table border="1" class="dataframe table">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>chr</th>
      <th>start</th>
      <th>end</th>
      <th>name</th>
      <th>strand</th>
      <th>source</th>
      <th>mean</th>
    </tr>
    <tr>
      <th>index</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>ENSG00000198886</th>
      <td>hsMT</td>
      <td>10760</td>
      <td>12137</td>
      <td>MT-ND4</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>2.657278e-10</td>
    </tr>
    <tr>
      <th>ENSG00000198727</th>
      <td>hsMT</td>
      <td>14747</td>
      <td>15887</td>
      <td>MT-CYB</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>2.137406e-10</td>
    </tr>
    <tr>
      <th>ENSG00000198899</th>
      <td>hsMT</td>
      <td>8527</td>
      <td>9207</td>
      <td>MT-ATP6</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.966070e-10</td>
    </tr>
    <tr>
      <th>ENSG00000198938</th>
      <td>hsMT</td>
      <td>9207</td>
      <td>9990</td>
      <td>MT-CO3</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.633298e-10</td>
    </tr>
    <tr>
      <th>ENSG00000198712</th>
      <td>hsMT</td>
      <td>7586</td>
      <td>8269</td>
      <td>MT-CO2</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.565673e-10</td>
    </tr>
    <tr>
      <th>ENSG00000087086</th>
      <td>hs19</td>
      <td>49468558</td>
      <td>49470135</td>
      <td>FTL</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.232170e-10</td>
    </tr>
    <tr>
      <th>ENSG00000111640</th>
      <td>hs12</td>
      <td>6643093</td>
      <td>6647537</td>
      <td>GAPDH</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.212971e-10</td>
    </tr>
    <tr>
      <th>ENSG00000198763</th>
      <td>hsMT</td>
      <td>4470</td>
      <td>5511</td>
      <td>MT-ND2</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.182991e-10</td>
    </tr>
    <tr>
      <th>ENSG00000075624</th>
      <td>hs7</td>
      <td>5566782</td>
      <td>5603415</td>
      <td>ACTB</td>
      <td>-</td>
      <td>H. sapiens</td>
      <td>1.138831e-10</td>
    </tr>
    <tr>
      <th>ENSG00000164587</th>
      <td>hs5</td>
      <td>149822753</td>
      <td>149829319</td>
      <td>RPS14</td>
      <td>-</td>
      <td>H. sapiens</td>
      <td>1.133044e-10</td>
    </tr>
    <tr>
      <th>ENSG00000084207</th>
      <td>hs11</td>
      <td>67351066</td>
      <td>67354131</td>
      <td>GSTP1</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.117254e-10</td>
    </tr>
    <tr>
      <th>ENSG00000181163</th>
      <td>hs5</td>
      <td>170814120</td>
      <td>170838141</td>
      <td>NPM1</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.109008e-10</td>
    </tr>
    <tr>
      <th>ENSG00000228253</th>
      <td>hsMT</td>
      <td>8366</td>
      <td>8572</td>
      <td>MT-ATP8</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.093323e-10</td>
    </tr>
    <tr>
      <th>ENSG00000137818</th>
      <td>hs15</td>
      <td>69745123</td>
      <td>69748255</td>
      <td>RPLP1</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.091205e-10</td>
    </tr>
    <tr>
      <th>ENSG00000231500</th>
      <td>hs6</td>
      <td>33239787</td>
      <td>33244287</td>
      <td>RPS18</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.037726e-10</td>
    </tr>
    <tr>
      <th>ENSG00000198804</th>
      <td>hsMT</td>
      <td>5904</td>
      <td>7445</td>
      <td>MT-CO1</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.030106e-10</td>
    </tr>
    <tr>
      <th>ENSG00000105372</th>
      <td>hs19</td>
      <td>42363988</td>
      <td>42376994</td>
      <td>RPS19</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>1.018074e-10</td>
    </tr>
    <tr>
      <th>ENSG00000149273</th>
      <td>hs11</td>
      <td>75110530</td>
      <td>75133324</td>
      <td>RPS3</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>9.832752e-11</td>
    </tr>
    <tr>
      <th>ENSG00000197061</th>
      <td>hs6</td>
      <td>26104104</td>
      <td>26104518</td>
      <td>HIST1H4C</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>9.703387e-11</td>
    </tr>
    <tr>
      <th>ENSG00000177954</th>
      <td>hs1</td>
      <td>153963235</td>
      <td>153964626</td>
      <td>RPS27</td>
      <td>+</td>
      <td>H. sapiens</td>
      <td>9.048103e-11</td>
    </tr>
  </tbody>
</table>
</div>
</div>

<div id="outline-container-org450128b" class="outline-3">
<h3 id="immune-census"><a id="org450128b"></a>Application to Census of Immune Cells</h3>
<div class="outline-text-3" id="text-immune-census">
<p>
The
<a href="https://data.humancellatlas.org/explore/projects/cc95ff89-2e68-4a08-a234-480eca21ce79">Census
of Immune Cells</a> is part of the Human Cell Atlas. Currently, it comprises
scRNA-seq data of 593,844 cells from 16 donors. The cells vary in donor sex,
donor ancestry, tissue of origin, as well as (latent) cell
types/subtypes/states within each donor.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">with</span> loompy.connect(<span class="org-string">'/project2/mstephens/aksarkar/projects/singlecell-ideas/data/human-cell-atlas/immune-cell-census.loom'</span>) <span class="org-keyword">as</span> con:
  <span class="org-variable-name">metadata</span> = pd.DataFrame(np.hstack([
    con.ca[<span class="org-string">'derived_organ_parts_label'</span>, <span class="org-string">'donor_organism.human_specific.ethnicity.ontology_label'</span>],
    con.ca[<span class="org-string">'donor_organism.provenance.document_id'</span>, <span class="org-string">'donor_organism.sex'</span>]]))
  <span class="org-keyword">print</span>(metadata.groupby([0,3,1,2]).agg(<span class="org-builtin">len</span>).to_frame().to_html(classes=<span class="org-string">'table'</span>))
</pre>
</div>

<table border="1" class="dataframe table">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th>0</th>
    </tr>
    <tr>
      <th>0</th>
      <th>3</th>
      <th>1</th>
      <th>2</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="8" valign="top">bone marrow</th>
      <th rowspan="4" valign="top">female</th>
      <th rowspan="4" valign="top">European</th>
      <th>085e737d-adb5-4597-bd54-5ebeda170038</th>
      <td>49716</td>
    </tr>
    <tr>
      <th>af7fe7a6-7d7e-4cdf-9799-909680fa9a3f</th>
      <td>44584</td>
    </tr>
    <tr>
      <th>cf514c66-88b2-45e4-a397-7fb362ae9950</th>
      <td>48630</td>
    </tr>
    <tr>
      <th>fb30bb83-0278-4117-bd42-e2e8dddfedfe</th>
      <td>49839</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">male</th>
      <th rowspan="2" valign="top">African American</th>
      <th>d23515a7-e182-4bc6-89e2-b1635885c0ec</th>
      <td>51239</td>
    </tr>
    <tr>
      <th>eb8fb36b-6e02-41c4-8760-3eabbde6bacb</th>
      <td>51024</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">European</th>
      <th>0a6c46dd-0905-4581-95eb-d89eef8a7213</th>
      <td>47167</td>
    </tr>
    <tr>
      <th>9aaf8a07-924f-456c-86dc-82f5da718246</th>
      <td>48784</td>
    </tr>
    <tr>
      <th rowspan="8" valign="top">umbilical cord blood</th>
      <th rowspan="3" valign="top">female</th>
      <th>Asian</th>
      <th>e4b5115d-3a0d-4c50-aba4-04b5f76810da</th>
      <td>57893</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">European</th>
      <th>4a404c91-0dbf-4246-bc23-d13aff961ba7</th>
      <td>45078</td>
    </tr>
    <tr>
      <th>509c507c-4759-452f-994e-d134d90329fd</th>
      <td>39584</td>
    </tr>
    <tr>
      <th rowspan="5" valign="top">male</th>
      <th>African American</th>
      <th>0b91cb1f-e2a8-413a-836c-1d38e7af3f2d</th>
      <td>54544</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">European</th>
      <th>53af872d-b838-44d6-ae1b-25b56405483c</th>
      <td>62609</td>
    </tr>
    <tr>
      <th>6072d1f5-aa0c-4ab1-a8a6-a00ab479a1ba</th>
      <td>52142</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">nan</th>
      <th>31f89559-2682-4bbc-84c6-826dfe4a4e39</th>
      <td>29455</td>
    </tr>
    <tr>
      <th>4e98f612-15ec-44ab-b5f9-39787f92b01a</th>
      <td>50571</td>
    </tr>
  </tbody>
</table>

<p>
To demonstrate the scalability of <code>mpebpm</code>, fit a point-Gamma distribution
to each gene in each donor, resulting in 254,432 EBPM problems. We
<a href="https://aksarkar.github.io/singlecell-modes/immune-census.html#orgc2a066a">previously
pre-processed the data</a> to <code>npz</code> format, which is much faster to read than
<code>h5ad</code> or <code>loom</code>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">y_csr</span> = ss.load_npz(<span class="org-string">'/scratch/midway2/aksarkar/modes/immune-cell-census.npz'</span>)
<span class="org-variable-name">genes</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/modes/immune-cell-census-genes.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
<span class="org-variable-name">donor</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/modes/immune-cell-census-samples.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)[<span class="org-string">'0'</span>]
<span class="org-variable-name">onehot</span> = ss.csr_matrix(pd.get_dummies(donor).values)
</pre>
</div>

<p>
Remove genes which only have zero observations in some donor.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-comment-delimiter"># </span><span class="org-comment">Important: CSC needed to subset on columns (genes)</span>
<span class="org-variable-name">y_csc</span> = y_csr.tocsc()
<span class="org-variable-name">keep</span> = (((y_csc.T @ onehot) &gt; 0).<span class="org-builtin">sum</span>(axis=1) == onehot.shape[1]).A.ravel()
<span class="org-variable-name">genes</span> = genes.loc[keep]
<span class="org-variable-name">y_csc</span> = y_csc[:,keep]
<span class="org-variable-name">y_csr</span> = y_csc.tocsr()
<span class="org-variable-name">s</span> = y_csr.<span class="org-builtin">sum</span>(axis=1).A.ravel()
y_csr
</pre>
</div>

<pre class="example">
&lt;593844x15902 sparse matrix of type '&lt;class 'numpy.int32'&gt;'
with 550918891 stored elements in Compressed Sparse Row format&gt;
</pre>

<p>
Fit <code>mpebpm</code> (6 minutes/epoch; 33 minutes fit).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-comment-delimiter"># </span><span class="org-comment">This converges quickly</span>
<span class="org-variable-name">init</span> = mpebpm.sgd.ebpm_gamma(
  y_csr, onehot=onehot, batch_size=128, lr=1e-2,
  max_epochs=1, shuffle=<span class="org-constant">True</span>)
<span class="org-variable-name">log_mu</span>, <span class="org-variable-name">neg_log_phi</span>, <span class="org-variable-name">logodds</span> = mpebpm.sgd.ebpm_point_gamma(
  y_csr, onehot=onehot, init=init, batch_size=128, lr=1e-2,
  max_epochs=5, shuffle=<span class="org-constant">True</span>, logdir=<span class="org-string">'runs/mpebpm6'</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">pd.DataFrame(log_mu, index=donor.unique(), columns=genes[<span class="org-string">'featurekey'</span>]).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-log-mu.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
pd.DataFrame(neg_log_phi, index=donor.unique(), columns=genes[<span class="org-string">'featurekey'</span>]).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-neg-log-phi.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
pd.DataFrame(logodds, index=donor.unique(), columns=genes[<span class="org-string">'featurekey'</span>]).to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-logodds.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
Read the estimated parameters.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">log_mu</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-log-mu.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
<span class="org-variable-name">neg_log_phi</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-neg-log-phi.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
<span class="org-variable-name">logodds</span> = pd.read_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-logodds.txt.gz'</span>, sep=<span class="org-string">'\t'</span>, index_col=0)
</pre>
</div>

<p>
Test each donor-gene combination for goodness-of-fit to the
<code>mpebpm</code>-estimated distribution.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">result</span> = <span class="org-builtin">dict</span>()
<span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(y_csr.shape[1]):
  <span class="org-variable-name">query</span> = y_csc[:,j].tocsr()
  <span class="org-keyword">for</span> k, name <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(donor.unique()):
    <span class="org-comment-delimiter"># </span><span class="org-comment">Important: scqtl.diagnostic blows up memory for some reason</span>
    <span class="org-variable-name">idx</span> = onehot[:,k].tocsc().indices
    <span class="org-variable-name">d</span>, <span class="org-variable-name">p</span> = scmodes.benchmark.gof._gof(
       query[idx].A.ravel(),
       cdf=scmodes.benchmark.gof._zig_cdf,
       pmf=scmodes.benchmark.gof._zig_pmf,
       size=s[idx].ravel(),
       log_mu=log_mu.iloc[k,j],
       log_phi=-neg_log_phi.iloc[k,j],
       logodds=logodds.iloc[k,j])
    result[(name, genes.iloc[j][<span class="org-string">'Gene'</span>])] = pd.Series({<span class="org-string">'stat'</span>: d, <span class="org-string">'p'</span>: p})
<span class="org-variable-name">result</span> = pd.DataFrame.from_dict(result, orient=<span class="org-string">'index'</span>)
<span class="org-variable-name">result.index.names</span> = [<span class="org-string">'donor'</span>, <span class="org-string">'gene'</span>]
<span class="org-variable-name">result</span> = result.reset_index()
result.to_csv(<span class="org-string">'/scratch/midway2/aksarkar/ideas/mpebpm-immune-census-gof.txt.gz'</span>, sep=<span class="org-string">'\t'</span>)
</pre>
</div>

<p>
0 - ee054e05-7b75-4fed-96f3-09c950cabb8c
</p>

<p>
Plot the histogram of GOF \(p\)-values.
</p>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2, 2)
plt.hist(result[<span class="org-string">'p'</span>], bins=np.linspace(0, 1, 11), color=<span class="org-string">'0.7'</span>, density=<span class="org-constant">True</span>)
plt.axhline(y=1, lw=1, ls=<span class="org-string">':'</span>, c=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'$p$-value'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/mpebpm-immune-census-gof.png" alt="mpebpm-immune-census-gof.png">
</p>
</div>

<p>
Look at an example.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">j</span> = 1
<span class="org-variable-name">k</span> = 0
<span class="org-variable-name">query</span> = y_csc[:,k].tocsr()
<span class="org-variable-name">idx</span> = onehot[:,j].tocsc().indices
<span class="org-variable-name">x</span> = query[idx].A.ravel()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">scmodes.benchmark.gof._gof(
  x, 
  cdf=scmodes.benchmark.gof._zig_cdf,
  pmf=scmodes.benchmark.gof._zig_pmf,
  size=s[idx],
  log_mu=init[0][k,j],
  log_phi=-init[1][k,j],)
</pre>
</div>

<pre class="example">
KstestResult(statistic=0.14346460385738558, pvalue=0.0)

</pre>


<div class="org-src-container">
<pre class="src src-ipython">scmodes.benchmark.gof._gof(
  x, 
  cdf=scmodes.benchmark.gof._zig_cdf,
  pmf=scmodes.benchmark.gof._zig_pmf,
  size=s[idx],
  log_mu=log_mu.iloc[k,j],
  log_phi=-neg_log_phi.iloc[k,j],
  logodds=logodds.iloc[k,j])
</pre>
</div>

<pre class="example">
KstestResult(statistic=0.13278115317033756, pvalue=0.0)

</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">res1</span> = scmodes.ebpm.ebpm_point_gamma(x, s[idx].ravel())
scmodes.benchmark.gof._gof(
  x, 
  cdf=scmodes.benchmark.gof._zig_cdf,
  pmf=scmodes.benchmark.gof._zig_pmf,
  size=s[idx],
  log_mu=res1[0],
  log_phi=-res1[1],
  logodds=res1[2])
</pre>
</div>

<pre class="example">
KstestResult(statistic=0.006399062002559908, pvalue=0.1017356159621166)

</pre>

<p>
Compare the negative log likelihood for this gene in this individual.
</p>

<div class="org-src-container">
<pre class="src src-ipython">pd.Series({<span class="org-string">'scmodes'</span>: scmodes.ebpm.wrappers._zinb_obj(res1[:-1], x, s[idx]),
           <span class="org-string">'mpebpm'</span>: scmodes.ebpm.wrappers._zinb_obj([log_mu.iloc[k,j], neg_log_phi.iloc[k,j], logodds.iloc[k,j]], x, s[idx])})
</pre>
</div>

<pre class="example">
scmodes     858.372281
mpebpm     7139.640261
dtype: float64
</pre>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">cm</span> = plt.get_cmap(<span class="org-string">'Paired'</span>)
plt.clf()
<span class="org-variable-name">fig</span>, <span class="org-variable-name">ax</span> = plt.subplots(2, 1)
fig.set_size_inches(5, 3.5)

<span class="org-variable-name">grid</span> = np.arange(x.<span class="org-builtin">max</span>() + 2)
ax[0].hist(x, bins=grid, color=<span class="org-string">'k'</span>)
ax[0].set_xticks(grid)
ax[0].set_xlabel(<span class="org-string">'Number of molecules'</span>)
ax[0].set_ylabel(<span class="org-string">'Number of cells'</span>)
ax[0].set_title(genes.iloc[1][<span class="org-string">'Gene'</span>])

<span class="org-variable-name">grid</span> = np.linspace(0, 1e-5, 1000)
<span class="org-variable-name">pi0</span> = sp.expit(logodds.iloc[k,j])
<span class="org-variable-name">F</span> = pi0 + (1 - pi0) * st.gamma(a=np.exp(-neg_log_phi.iloc[k,j]), scale=np.exp(log_mu.iloc[k,j] - neg_log_phi.iloc[k,j])).cdf(grid)
ax[1].plot(grid, F, c=cm(0), lw=1, label=<span class="org-string">'mpebpm'</span>)

<span class="org-variable-name">pi0</span> = sp.expit(res1[2])
<span class="org-variable-name">F</span> = pi0 + (1 - pi0) * st.gamma(a=np.exp(-res1[1]), scale=np.exp(res1[0] - res1[1])).cdf(grid)
ax[1].plot(grid, F, c=cm(1), lw=1, label=<span class="org-string">'scmodes'</span>)
ax[1].set_xlabel(<span class="org-string">'Latent gene expression'</span>)
ax[1].set_ylabel(<span class="org-string">'CDF'</span>)
ax[1].legend(frameon=<span class="org-constant">False</span>)
fig.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/mpebpm.org/ic-dpm1.png" alt="ic-dpm1.png">
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2020-05-14 Thu 13:29</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
