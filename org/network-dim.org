#+TITLE: Why do high-dimensional networks produce low-dimensional activity?
#+SETUPFILE: setup.org

* Introduction

  [[https://www.biorxiv.org/content/biorxiv/early/2018/08/17/394684.full.pdf][Recanatesi et al. 2018]] investigated how the dimensionality of neuron spike
  activity data ("spike trains") depends on the connectivity of neurons. Spike
  trains can be represented as a matrix \([x_{ij}]\), \(i = 1, \ldots, n\), \(j
  = 1, \ldots, p\) where \(x_{ij}\) denotes the number of times neuron \(i\)
  fired in time interval \([t_{j - 1}, t_{j})\).

  The initial ideas are motivated by simulations rather than real data, which
  we examine here.

* Setup
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 1

  #+CALL: ipython3(venv="singlecell",partition="mstephens") :exports none :dir /scratch/midway2/aksarkar/ideas/

  #+RESULTS:
  : Submitted batch job 63678585

  #+BEGIN_SRC ipython
    import collections
    import numpy as np
    import pandas as pd
    import scipy.sparse as ss
    import scipy.stats as st
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[38]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
    plt.rcParams['font.family'] = 'Nimbus Sans'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

* Methods
** Generating spike trains

   The activity of neuron \(i\), \(s_i(t)\), is assumed to be a
   time-inhomogeneous Poisson process with rate \(\lambda_i(t)\). The rate
   \(\lambda_i(t)\) depends on a baseline rate \(\mu_i\), the activity of other
   neurons it is connected to \(s_j(t)\) (where connections have weights
   \(w_{ij}\)), and external stimulus \(\alpha_i(t)\). This can be written

   \[ \lambda_i(t) = \mu_i + \alpha_i(t) + \sum_j w_{ij} s_j(t) \]

   The events \(s_i(t)\) are then binned between time points \(t_0, \ldots,
   t_p\) to generate the observed data \(X = [x_{ij}]\), of dimension \(n
   \times p\). The motivating questions are: is \(X\) low rank ("lower
   dimension")? How does the rank/dimension of the observed data depend on the
   network \(W\)?

   The starting point of the analysis is to ask about the dimension of \(X\)
   for random graphs \(W\), by simply simulating random graphs. The simplest
   notion of "random graph" is the Erdös-Rényi model \(G(n, p)\), which denotes
   a graph of \(n\) nodes where each (directed) edge is included iid with
   probability \(p\).

   #+BEGIN_SRC ipython
     def er_random_graph(n, p):
       return st.binom(n=1, p=p).rvs(size=(n, n))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[9]:
   :END:

   Here, edge weights are either 0 or 1 (i.e., we model excitatory neurons
   only). As an example, generate data for randomly connected neurons with no
   external stimulus.

   #+BEGIN_SRC ipython
     def simulate(t_max, A, mu0, seed=0):
       np.random.seed(seed)
       events = []
       t = 0
       while t < t_max:
         if events:
           y = mu0 + A[events[-1][1]]
           if ss.issparse(A):
             y = y.A.ravel()
         else:
           y = mu0
         wait = np.random.exponential(scale=1 / y)
         event = np.argmin(wait)
         events.append((t + wait[event], event))
         t += wait[event]
       return np.array(events)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[79]:
   :END:

   #+BEGIN_SRC ipython
     N = 10
     pi = 0.2
     A = er_random_graph(N, pi)
     mu0 = np.random.gamma(shape=.5, scale=.5, size=N)
     t_max = 10
     S = simulate(t_max, A, mu0)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[88]:
   :END:

   Plot the simulated spike train.

   #+BEGIN_SRC ipython :ipyfile figure/network-dim.org/random-firing.png
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     plt.scatter(S[:,0], S[:,1], c='k', marker='|')
     plt.xlabel('Time')
     plt.ylabel('Neuron')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[89]:
   [[file:figure/network-dim.org/random-firing.png]]
   :END:

   Now bin the spikes into time intervals of length \(0.01\) (we should expect
   to have roughly 1000 of them), and estimate the eigenspectrum (equivalently,
   singular values) of the data.

   #+BEGIN_SRC ipython
     X = pd.DataFrame(S).groupby(1).apply(lambda x: pd.Series(np.histogram(x[0], bins=np.arange(0, t_max, .01))[0]))
     d = np.linalg.svd(X)[1]
     d
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[103]:
   #+BEGIN_EXAMPLE
     array([4.47213595, 3.16227766, 2.72290535, 2.44948974, 2.14144494,
     1.73205081, 1.41421356, 1.41421356, 1.41421356, 1.        ])
   #+END_EXAMPLE
   :END:

   Recanatesi et al. define the dimension as \((\sum_i \lambda_i)^2 / \sum_i
   \lambda_i^2\). We estimate it in the simulated data:

   #+BEGIN_SRC ipython
     np.square(np.square(d).sum()) / (d ** 4).sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[106]:
   : 5.305993690851737
   :END:

   A different notion of random graph is the [[https://en.wikipedia.org/wiki/Barab%25C3%25A1si%25E2%2580%2593Albert_model][Barabási–Albert model]], which
   generates scale-free networks. (The ER model cannot generate such networks.)

   #+BEGIN_SRC ipython
     def ba_random_graph(n, m=2):
       A = collections.defaultdict(set)
       # Start from a fully connected network
       A[0].add(1)
       A[1].add(0)
       for i in range(2, n):
         p = np.array([float(len(A[k])) for k in A])
         p /= p.sum()
         e = set(np.random.choice(a=i, p=p, size=2))
         A[i] = e
         for j in e:
           A[j].add(i)
       # Convert adjacency list to adjacency matrix
       ind = np.array([(k, v) for k in A for v in A[k]])
       A = ss.coo_matrix((np.ones(len(ind)).astype(int), (ind[:,0], ind[:,1]))).tocsr()
       return A
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[72]:
   :END:

   Generate spike trains for a random BA graph, and estimate the dimension of
   the generated data.

   #+BEGIN_SRC ipython :async t
     N = 10
     A = ba_random_graph(N)
     mu0 = np.random.gamma(shape=.5, scale=.5, size=N)
     t_max = 10
     S = simulate(t_max, A, mu0)
     X = pd.DataFrame(S).groupby(1).apply(lambda x: pd.Series(np.histogram(x[0], bins=np.arange(0, t_max, .01))[0]))
     d = np.linalg.svd(X)[1]
     np.square(np.square(d).sum()) / (d ** 4).sum()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[84]:
   : 4.878048780487806
   :END:
