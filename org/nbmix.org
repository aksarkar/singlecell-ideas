#+TITLE: Model-based clustering of scRNA-seq data
#+SETUPFILE: setup.org

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introdcution
  :END:

  Two major strategies for clustering scRNA-seq data are:

  1. Building a \(k\)-nearest neighbor graph on the data, and applying a
     community detection algorithm (e.g.,
     [[https://doi.org/10.1088/1742-5468/2008/10/P10008][Blondel et al. 2008]],
     [[https://arxiv.org/abs/1810.08473][Traag et al. 2018]])
  2. Fitting a topic model to the data
     (e.g., [[https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1006599][Dey
     et al. 2017]],
     [[https://www.nature.com/articles/s41592-019-0367-1][GonzÃ¡les-Blas et
     al. 2019]])

  The main disadvantage of strategy (1) is that, as commonly applied to
  transformed counts, it does not separate measurement error and biological
  variation of interest. The main disadvantage of strategy (2) is that it does
  not account for transcriptional noise
  ([[https://doi.org/10.1016/j.cell.2008.09.050][Raj 2008]]). Here, we develop
  a simple model-based clustering algorithm which addresses both of these
  issues.

* Setup
  :PROPERTIES:
  :CUSTOM_ID: setup
  :END:

  #+BEGIN_SRC emacs-lisp :exports none
    (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
    (org-babel-lob-ingest "/home/aksarkar/.emacs.d/org-templates/library.org")
  #+END_SRC

  #+RESULTS:
  : 2

  #+CALL: ipython3(venv="singlecell",partition="mstephens",memory="4G") :exports none :dir /scratch/midway2/aksarkar/singlecell/

  #+CALL: ipython3(venv="singlecell",partition="gpu2",opts="--gres=gpu:1",memory="16G") :exports none :dir /scratch/midway2/aksarkar/singlecell/

  #+BEGIN_SRC ipython
    import anndata
    import mpebpm.gam_mix
    import mpebpm.sgd
    import numpy as np
    import pandas as pd
    import scanpy as sc
    import scipy.optimize as so
    import scipy.special as sp
    import scipy.stats as st
    import scmodes
    import time
    import torch
    import torch.utils.data as td
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[1]:
  :END:

  #+BEGIN_SRC ipython
    %matplotlib inline
    %config InlineBackend.figure_formats = set(['retina'])
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[2]:
  :END:

  #+BEGIN_SRC ipython
    import matplotlib
    import matplotlib.pyplot as plt
    plt.rcParams['figure.facecolor'] = 'w'
    plt.rcParams['font.family'] = 'Nimbus Sans'
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[3]:
  :END:

  #+CALL: tensorboard(venv="singlecell") :session tensorboard :dir /scratch/midway2/aksarkar/singlecell/

* Methods
  :PROPERTIES:
  :CUSTOM_ID: method
  :END:
** Model specification

   We assume \(
   \DeclareMathOperator\Gam{Gamma}
   \DeclareMathOperator\Mult{Multinomial}
   \DeclareMathOperator\N{\mathcal{N}}
   \DeclareMathOperator\Pois{Poisson}
   \DeclareMathOperator\diag{diag}
   \newcommand\xiplus{x_{i+}}
   \newcommand\mi{\mathbf{I}}
   \newcommand\vu{\mathbf{u}}
   \newcommand\vx{\mathbf{x}}
   \newcommand\vz{\mathbf{z}}
   \newcommand\vlambda{\boldsymbol{\lambda}}
   \newcommand\vmu{\boldsymbol{\mu}}
   \newcommand\vphi{\boldsymbol{\phi}}
   \newcommand\vpi{\boldsymbol{\pi}}
   \)

   \begin{align}
     x_{ij} \mid \xiplus, \lambda_{ij} &\sim \Pois(\xiplus \lambda_{ij})\\
     \lambda_{ij} \mid \vpi_i, \vmu_k, \vphi_k &\sim \sum_{k=1}^{K} \pi_{ik} \Gam(\phi_{kj}^{-1}, \phi_{kj}^{-1}\mu_{kj}^{-1}),
   \end{align}

   where

   - \(x_{ij}\) denotes the number of molecules of gene \(j = 1, \ldots, p\)
     observed in cell \(i = 1, \ldots, n\)
   - \(\xiplus \triangleq \sum_j x_{ij}\) denotes the total number of molecules
     observed in cell \(i\)
   - \(\vpi_i\) denotes cluster assignment probabilities for cell \(i\)
   - \(\vmu_k\) denotes the cluster "centroid" for cluster \(k\), and
     \(\vphi_k\) describes stochastic perturbations within each cluster

   The intuition behind this model is that each cluster \(k\) is defined by a
   collection of independent Gamma distributions (parameterized by shape and
   rate), one per gene \(j\), which describe the distribution of true gene
   expression for each gene in each cluster
   ([[https://dx.doi.org/10.1101/2020.04.07.030007][Sarkar and Stephens
   2020]]). In this parameterization, each Gamma distribution has mean
   \(\mu_{kj}\) and variance \(\mu_{kj}^2\phi_{kj}\). Under this model, the
   marginal likelihood is a mixture of negative binomials

   \begin{equation}
     p(x_{ij} \mid \xiplus, \vpi_i, \vmu_k, \vphi_k) = \sum_{k=1}^{K} \pi_{ik} \frac{\Gamma(x_{ij} + 1 / \phi_{kj})}{\Gamma(1 / \phi_{kj})\Gamma(x_{ij} + 1)}\left(\frac{\xiplus\mu_{kj}\phi_{kj}}{1 + \xiplus\mu_{kj}\phi_{kj}}\right)^{x_{ij}} \left(\frac{1}{1 + \xiplus\mu_{kj}\phi_{kj}}\right)^{1/\phi_{kj}}.
   \end{equation}

** EM for Poisson-Gamma compound distribution
   :PROPERTIES:
   :CUSTOM_ID: em-nbmix
   :END:

   Considering just a simple Gamma prior,
   [[https://doi.org/10.1017/S0515036100014033][Karlis 2005]] gives an EM
   algorithm for fitting the resulting Gamma mixture of Poissons. The key idea
   is that, due to Poisson-Gamma conjugacy, the exact posterior is analytic, as
   are the necessary posterior moments. The main disadvantage of this approach
   is that it requires (one-dimensional) numerical optimization in the M step.

   \begin{align}
     x_i \mid \xiplus, \lambda_i &\sim \Pois(\xiplus \lambda_i)\\
     \lambda_i \mid \alpha, \beta &\sim \Gam(\alpha, \beta)\\
     \lambda_i \mid x_i, \xiplus, \alpha, \beta &\sim q \triangleq \Gam(x_i + \alpha, \xiplus + \beta)\\
     E_q[\lambda_i] &= \frac{x_i + \alpha}{\xiplus + \beta}\\
     E_q[\ln \lambda_i] &= \psi(x + \alpha) - \log(\xiplus + \beta)\\
     E_q[\ln p(x_i, \lambda_i \mid \xiplus, \alpha, \beta)] &= \ell_i \triangleq x_i E_q[\ln \lambda_i] - E_q[\lambda_i] - \ln\Gamma(x_i + 1) + \alpha \ln\beta - \ln\Gamma(\alpha) + (\alpha - 1) E_q[\lambda_i] - \beta E_q[\lambda_i]\\
     \ell &= \sum_i \ell_i\\
     \frac{\partial\ell}{\partial\beta} &= \sum_i \frac{\alpha}{\beta} - E_q[\lambda_i] = 0\\
     \beta &= \frac{\bar{\lambda}}{\alpha}\\
     \frac{\partial\ell}{\partial\alpha} &= \sum_i \ln \beta - \psi(\alpha) + E_q[\ln x_i]\\
     \frac{\partial^2\ell}{\partial\alpha^2} &= -n \psi^{(1)}(\alpha)
   \end{align}

   where \(\psi\) denotes the digamma function and \(\psi^{(1)}\) denotes the
   trigamma function. The algorithm uses a partial M step (single
   Newton-Raphson update) for \(\alpha\).

   #+BEGIN_SRC ipython
     def ebpm_gamma_em(x, s, max_iters=100, tol=1e-3):
       """Return fitted parameters assuming g is a Gamma distribution

       Returns log mu and -log phi

       x - array-like [n,]
       s - array-like [n,]

       """
       n = x.shape[0]
       assert x.shape == (n,)
       assert x.shape == s.shape
       # a = 1 / phi; b = 1 / (mu phi)
       a = 1
       # Initialize at the Poisson MLE
       b = s.sum() / x.sum()
       obj = []
       obj.append(st.nbinom(n=a, p=1 / (1 + s / b)).logpmf(x).sum())
       for i in range(max_iters):
         # E[lam | x]
         pm = (x + a) / (s + b)
         assert (pm > 0).all()
         # E[ln lam | x]
         plm = sp.digamma(x + a) - np.log(s + b)
         b = a / pm.mean()
         # Important: this appears to be incorrect in Karlis 2005
         a += (np.log(b) - sp.digamma(a) + plm.mean()) / sp.polygamma(1, a)
         assert a > 0
         assert b > 0
         obj.append(st.nbinom(n=a, p=1 / (1 + s / b)).logpmf(x).sum())
         if obj[-1] < obj[-2]:
           raise RuntimeError('llik decreased')
         elif obj[-1] - obj[-2] < tol:
           log_inv_disp = np.log(a)
           log_mean = -np.log(b) + np.log(a)
           return log_mean, log_inv_disp, obj
       else:
         raise RuntimeError('failed to converge in max_iters')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[101]:
   :END:

   Try EM for a simple example.

   #+BEGIN_SRC ipython
     rng = np.random.default_rng(1)
     n = 100
     log_mean = -10
     log_inv_disp = 0
     s = np.repeat(1e5, n)
     lam = rng.gamma(shape=np.exp(log_inv_disp), scale=np.exp(log_mean - log_inv_disp), size=n)
     x = rng.poisson(s * lam)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[104]:
   :END:

   #+BEGIN_SRC ipython :async t
     log_mu, neg_log_phi, trace = ebpm_gamma_em(x, s)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[105]:
   :END:

   Plot the simulated data, the ground truth marginal distribution on counts,
   and the NB MLE.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/nb-em.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(4.5, 2.5)
     grid = np.arange(x.max() + 1)
     plt.hist(x, bins=grid, color='0.7', density=True)
     plt.plot(grid + .5, st.nbinom(n=np.exp(-log_inv_disp), p=1 / (1 + s[0] * np.exp(log_mean - log_inv_disp))).pmf(grid), lw=1, color=cm(0), label='Ground truth')
     plt.plot(grid + .5, st.nbinom(n=np.exp(neg_log_phi), p=1 / (1 + s[0] * np.exp(log_mu - neg_log_phi))).pmf(grid), lw=1, color=cm(1), label='NB MLE')
     plt.legend(frameon=False)
     plt.xlabel('Number of molecules')
     plt.ylabel('Density')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[106]:
   [[file:figure/nbmix.org/nb-em.png]]
   :END:

   Try a more extensive evaluation of the method.

   #+BEGIN_SRC ipython :async t
     n = 100
     s = np.repeat(1e5, n)
     result = dict()
     for trial in range(5):
       for log_mean in np.linspace(-12, -6, 7):
         for log_inv_disp in np.linspace(0, 4, 5):
           rng = np.random.default_rng(trial)
           lam = rng.gamma(shape=np.exp(log_inv_disp), scale=np.exp(log_mean - log_inv_disp), size=n)
           x = rng.poisson(s * lam)
           start = time.time()
           log_mean_hat, log_inv_disp_hat, trace = ebpm_gamma_em(x, s, max_iters=1000)
           elapsed = time.time() - start
           result[(log_mean, log_inv_disp, trial)] = pd.Series([log_mean_hat, log_inv_disp_hat, len(trace), elapsed])
     result = (pd.DataFrame.from_dict(result, orient='index')
               .reset_index()
               .rename({f'level_{i}': k for i, k in enumerate(['log_mean', 'log_inv_disp', 'trial'])}, axis=1)
               .rename({i: k for i, k in enumerate(['log_mean_hat', 'log_inv_disp_hat', 'num_iters', 'elapsed'])}, axis=1))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[138]:
   :END:

   Plot the estimates against the ground truth values.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/nb-em-sim.png
     plt.clf()
     fig, ax = plt.subplots(1, 2)
     fig.set_size_inches(4.5, 2.5)
     for a in ax:
       a.set_aspect('equal', adjustable='datalim')
     ax[0].scatter(result['log_mean'], result['log_mean_hat'], c='k', s=1)
     ax[0].set_xlabel('Ground truth $\ln(\mu)$')
     ax[0].set_ylabel('Estimated $\ln(\mu)$')
     ax[1].scatter(-result['log_inv_disp'], -result['log_inv_disp_hat'], c='k', s=1)
     ax[1].set_xlabel('Ground truth $\ln(\phi)$')
     ax[1].set_ylabel('Estimated $\ln(\phi)$')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[139]:
   [[file:figure/nbmix.org/nb-em-sim.png]]
   :END:

   Estimate the average time (seconds) taken to fit each trial.

   #+BEGIN_SRC ipython
     result['elapsed'].mean(), result['elapsed'].std()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[140]:
   : (0.18343861034938266, 0.18248113994496618)
   :END:

** EM for Poisson-Gamma mixture
   :PROPERTIES:
   :CUSTOM_ID: em-nbmix
   :END:

   Considering the Gamma mixture prior, we can estimate \(\vpi, \vmu, \vphi\) by
   maximizing the likelihood using an EM algorithm. Letting \(z_{ik} \in \{0,
   1\}\) indicate whether cell \(i\) is assigned to cluster \(k\), the exact
   posterior

   \begin{align}
     q(z_{i1}, \ldots, z_{iK}) &\triangleq p(z_{ik} \mid \cdot) = \Mult(1, \alpha_{i1}, \ldots, \alpha_{iK})\\
     \alpha_{ik} &\propto \sum_j \frac{\Gamma(x_{ij} + 1 / \phi_{kj})}{\Gamma(1 / \phi_{kj})\Gamma(x_{ij} + 1)}\left(\frac{\xiplus\mu_{kj}\phi_{kj}}{1 + \xiplus\mu_{kj}\phi_{kj}}\right)^{x_{ij}} \left(\frac{1}{1 + \xiplus\mu_{kj}\phi_{kj}}\right)^{1/\phi_{kj}}.
   \end{align}

   The expected log joint with respect to \(q\)

   \begin{multline}
     E_q[\ln p(x_{ij}, z_{ik} \mid \xiplus, \vpi_i, \vmu_k, \vphi_k)] = \sum_k E_q[z_{ik}] \left[x_{ij} \ln\left(\frac{\xiplus\mu_{kj}\phi_{kj}}{1 + \xiplus\mu_{kj}\phi_{kj}}\right)\right.\\
       \left. - \phi_{kj}^{-1} \ln(1 + \xiplus\mu_{kj}\phi_{kj}) + \ln\Gamma(x_{ij} + 1 / \phi_{kj}) - \ln\Gamma(1 / \phi_{kj}) - \ln\Gamma(x_{ij} + 1)\right].
   \end{multline}

   In the E step, the necessary expectations are analytic. In the M step, we
   can improve the likelihood, e.g. by [[file:mepbpm.org][(batch) gradient
   descent]].

** EM for Poisson-Log compound distribution

   The NB distribution can be derived as a
   [[https://en.wikipedia.org/wiki/Negative_binomial_distribution#Representation_as_compound_Poisson_distribution][Poisson-distributed
   sum]] of
   [[https://en.wikipedia.org/wiki/Logarithmic_distribution][Log-distributed
   random variables]] (Quenouille 1949)

   \begin{align}
     x_i \mid y_1, \ldots, y_{m_i}, m_i &= \sum_{t=1}^{m_i} y_t\\
     m_i \mid \lambda &\sim \Pois(\lambda)\\
     p(y_t \mid \theta) &= -\frac{\theta^{y_t}}{y_t \ln(1 - \theta)}, \quad t = 1, 2, \ldots\\
     p(x_i \mid \lambda, \theta) &\propto p^n (1 - p)^{x_i}, \quad n = -\lambda / \log(1 - \theta), p = 1 - \theta
   \end{align}

   To connect this parameterization to our parameterization, we have \(n =
   1/\phi\) and \(p = 1 / (1 + \xiplus\mu\phi)\). Adamidis 1999 uses this fact to
   derive a new auxiliary variable representation of the NB distribution

   \begin{equation}
     p(y_t, z_t \mid \theta) = \frac{(1 - \theta)^{z_t} \theta^{y_t - 1}}{y_t}, z_t \in (0, 1), y_t \in \mathbb{N}
   \end{equation}

   which they claim admits an EM algorithm with analytic M step. Letting \(q
   \triangleq p(m_i, y_1, \ldots, z_1, \ldots \mid x_i, n, p)\),

   \begin{multline}
     E_q[\ln p(x_i \mid m_i, y_1, \ldots, z_1, \ldots, \lambda, \theta)] = E_q[m_i] \ln\lambda - \lambda - E_q[\ln\Gamma(m_i + 1)]\\
     + E_q[\textstyle\sum_{t=1}^{m_i} z_t] \ln(1 - \theta) + (\textstyle\sum_{t=1}^{m_i} E_q[y_t] - E_q[m_i]) \ln \theta + \mathrm{const}
   \end{multline}

   However, it appears they neglect the intractable term \(E_q[\ln\Gamma(m_i +
   1)]\) in their derivation, and the algorithm as given does not appear to
   improve the expected log joint probability.

   #+BEGIN_SRC ipython
     def pois_log_series_em(x, s, max_iters=100, tol=1e-3):
       n = x.shape[0]
       assert x.shape == (n,)
       assert x.shape == s.shape
       z = .5
       m = .5 * x
       theta = (x - m).sum() / (x + m * z - m).sum()
       lam = m.mean()
       obj = [st.nbinom(n=-lam / np.log(1 - theta), p=1 - theta).logpmf(x).sum()]
       assert np.isfinite(obj[-1]) and obj[-1] < 0
       for i in range(max_iters):
         alpha = -1 / np.log(1 - theta)
         z = -((1 - theta) / theta - alpha)
         assert np.ndim(z) == 0
         assert 0 < z < 1
         n = lam * alpha
         m = n * (sp.digamma(n + x) - sp.digamma(n))
         assert m.shape == x.shape
         theta = (x - m).sum() / (x + m * z - m).sum()
         assert 0 < theta < 1
         lam = m.mean()
         assert lam > 0
         obj.append(st.nbinom(n=n, p=1 - theta).logpmf(x).sum())
         assert np.isfinite(obj[-1]) and obj[-1] < 0
         if obj[-1] < obj[-2]:
           raise RuntimeError('llik decreased')
         elif obj[-1] - obj[-2] < tol:
           log_inv_disp = -np.log(n)
           log_mean = np.log(theta) - np.log(1 - theta) - np.log(s) - log_inv_disp
           return log_mean, log_inv_disp, obj
       else:
         raise RuntimeError('failed to converge in max_iters')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[41]:
   :END:

   Try EM for a simple example.

   #+BEGIN_SRC ipython
     rng = np.random.default_rng(1)
     n = 100
     log_mean = -10
     log_inv_disp = 0
     s = np.repeat(1e5, n)
     lam = rng.gamma(shape=np.exp(log_inv_disp), scale=np.exp(log_mean - log_inv_disp), size=n)
     x = rng.poisson(s * lam)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[5]:
   :END:

   #+BEGIN_SRC ipython :async t
     log_mu, neg_log_phi, trace = pois_log_series_em(x, s)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

** Amortized inference

   Another alternative algorithm, which is amenable to stochastic gradient
   descent and online learning, is to use the fact that EM can be viewed as
   maximizing the evidence lower bound
   ([[https://doi.org/10.1007/978-94-011-5014-9_12][Neal and Hinton 1998]])

   \begin{equation}
     \max_{q, \theta} \ln p(x \mid \theta) - \mathcal{KL}(q(z) \Vert p(z \mid x, \theta)) = \max_{q, \theta} E_q[\ln p(x \mid z, \theta)] - \mathcal{KL}(q(z) \Vert p(z \mid \theta)).
   \end{equation}

   Exact EM corresponds to (fully) alternately optimizing \(q = p(z \mid x,
   \theta)\) and \(\theta\); however, we can instead amortize inference
   ([[https://escholarship.org/content/qt34j1h7k5/qt34j1h7k5.pdf][Gershman and
   Goodman 2014]], [[https://arxiv.org/abs/1312.6114][Kingma and Welling
   2014]], [[http://proceedings.mlr.press/v32/rezende14.html][Rezende et
   al. 2014]]), learning a neural network \(f_z\) mapping \(\vx_i \rightarrow
   \vz_i\)

   \begin{align}
     p(z_{i1}, \ldots, z_{iK}) &= \Mult(1, \vpi)\\
     q(z_{i1}, \ldots, z_{iK} \mid \vx_i) &= \Mult(1, f_z(\vx_i)).
   \end{align}

* Results
  :PROPERTIES:
  :CUSTOM_ID: results
  :END:
** Real data example
   :PROPERTIES:
   :CUSTOM_ID: example
   :END:

   Read sorted immune cell scRNA-seq data
   ([[https://dx.doi.org/10.1038/ncomms14049][Zheng et al. 2017]]).

   #+BEGIN_SRC ipython :async t
     dat = anndata.read_h5ad('/scratch/midway2/aksarkar/ideas/zheng-10-way.h5ad')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   :END:

   Get 256 B cells and 256 cytotoxic T cells.

   #+BEGIN_SRC ipython :async t
     b_cells = dat[dat.obs['cell_type'] == 'b_cells']
     sc.pp.subsample(b_cells, n_obs=256, random_state=0)
     t_cells = dat[dat.obs['cell_type'] == 'cytotoxic_t']
     sc.pp.subsample(t_cells, n_obs=256)
     temp = b_cells.concatenate(t_cells)
     sc.pp.filter_genes(temp, min_counts=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[7]:
   :END:

   Plot a UMAP embedding of the data, coloring points by the ground truth
   labels.

   #+BEGIN_SRC ipython :async t
     sc.pp.pca(temp)
     sc.pp.neighbors(temp)
     sc.tl.umap(temp)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[6]:
   :END:

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/sim-ex.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i, c in enumerate(temp.obs['cell_type'].unique()):
       plt.plot(*temp[temp.obs['cell_type'] == c].obsm["X_umap"].T, c=cm(i), marker='.', ms=2, lw=0, label=f'{c}')
     plt.legend(frameon=False, markerscale=4, handletextpad=0)
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[7]:
   [[file:figure/nbmix.org/sim-ex.png]]
   :END:

** Leiden algorithm
   :PROPERTIES:
   :CUSTOM_ID: leiden
   :END:

    Apply the Leiden algorithm ([[https://arxiv.org/abs/1810.08473][Traag et
    al. 2018]]) to the data (<1 s).

    #+BEGIN_SRC ipython :async t
      sc.tl.leiden(temp, random_state=0)
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[8]:
    :END:

    #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/leiden-ex.png
      cm = plt.get_cmap('Dark2')
      plt.clf()
      plt.gcf().set_size_inches(3, 3)
      for i, c in enumerate(temp.obs['leiden'].unique()):
        plt.plot(*temp[temp.obs['leiden'] == c].obsm["X_umap"].T, c=cm(i), marker='.', ms=2, lw=0, label=f'Cluster {i}')
      plt.legend(frameon=False, markerscale=4, handletextpad=0)
      plt.xlabel('UMAP 1')
      plt.ylabel('UMAP 2')
      plt.tight_layout()
    #+END_SRC

    #+RESULTS:
    :RESULTS:
    # Out[9]:
    [[file:figure/nbmix.org/leiden-ex.png]]
    :END:

** MPEBPM
   :PROPERTIES:
   :CUSTOM_ID: mpebpm
   :END:

   First, start from the ground truth \(z\) (labels), and estimate the Gamma
   expression models.

   #+BEGIN_SRC ipython :async t
     fit0 = mpebpm.sgd.ebpm_gamma(
       temp.X,
       onehot=pd.get_dummies(temp.obs['cell_type']).values,
       batch_size=32,
       num_epochs=320,
       shuffle=True,
       log_dir='runs/nbmix/pretrain/')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[49]:
   :END:

   #+BEGIN_SRC ipython
     y = pd.get_dummies(temp.obs['cell_type']).values
     s = temp.X.sum(axis=1)
     nb_llik = y.T @ st.nbinom(n=np.exp(y @ fit0[1]), p=1 / (1 + s.A * (y @ np.exp(fit0[0] - fit0[1])))).logpmf(temp.X.A)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[63]:
   :END:

   For comparison, estimate a point mass expression model for each gene, for
   each cluster.

   #+BEGIN_SRC ipython
     y = pd.get_dummies(temp.obs['cell_type']).values
     s = temp.X.sum(axis=1)
     fit_pois = (y.T @ temp.X) / (y.T @ s)
     pois_llik = y.T @ st.poisson(mu=s.A * (y @ fit_pois).A).logpmf(temp.X.A)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[65]:
   :END:

   For each gene, for each cluster, plot the log likelihood under the point
   mass and Gamma expression models.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/ex-pois-nb-llik.png
     plt.clf()
     fig, ax = plt.subplots(1, 2, sharey=True)
     fig.set_size_inches(4.5, 2.5)
     lim = [-1500, 0]
     for i, (a, t) in enumerate(zip(ax, ['B cell', 'Cytotoxic T'])):
       a.scatter(pois_llik[i], nb_llik[i], c='k', s=1, alpha=0.2)
       a.plot(lim, lim, c='r', lw=1, ls=':')
       a.set_xlim(lim)
       a.set_ylim(lim)
       a.set_title(t)
       a.set_xlabel('Poisson log lik')
     ax[0].set_ylabel('NB log lik')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[71]:
   [[file:figure/nbmix.org/ex-pois-nb-llik.png]]
   :END:

   Look at the differences in the estimated mean parameter for each gene, to
   see how many genes are informative about the labels.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/mepbpm-log-mu.png
     query = np.sort(np.diff(fit0[0], axis=0).ravel())
     plt.clf()
     plt.gcf().set_size_inches(4, 2)
     plt.plot(query, lw=1, c='k')
     plt.axhline(y=0, lw=1, ls=':', c='k')
     plt.xlabel('Gene')
     plt.ylabel(r'Diff $\ln(\mu_j)$')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[29]:
   [[file:figure/nbmix.org/mepbpm-log-mu.png]]
   :END:

   Estimate the cluster weights.

   #+BEGIN_SRC ipython
     L = mpebpm.gam_mix._nb_mix_llik(
       x=torch.tensor(temp.X.A, dtype=torch.float), 
       s=torch.tensor(temp.X.sum(axis=1), dtype=torch.float),
       log_mean=torch.tensor(fit0[0], dtype=torch.float),
       log_inv_disp=torch.tensor(fit0[1], dtype=torch.float))
     zhat = torch.nn.functional.softmax(L, dim=1)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[33]:
   :END:

   Plot the log likelihood difference between the two components for each data
   point.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/mpebpm-llik-diff.png
     plt.clf()
     plt.gcf().set_size_inches(4, 2)
     plt.plot(np.diff(L).ravel(), lw=0, marker='.', c='k', ms=2)
     plt.axhline(y=0, lw=1, ls=':', c='k')
     plt.xlabel('Cell')
     plt.ylabel('Diff log lik')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[42]:
   [[file:figure/nbmix.org/mpebpm-llik-diff.png]]
   :END:

   Compute the cross entropy between the estimated \(\hat{z}\) and the ground
   truth.

   #+BEGIN_SRC ipython
     torch.nn.functional.binary_cross_entropy(
       zhat,
       torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[108]:
   : tensor(0.)
   :END:

   Compute a weighted log likelihood.

   #+BEGIN_SRC ipython
     w = torch.rand([512, 2])
     w /= w.sum(dim=1).unsqueeze(-1)
     m, _ = L.max(dim=1, keepdim=True)
     (m + torch.log(w * torch.exp(L - m) + 1e-8)).mean()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[43]:
   : tensor(-1872.5645)
   :END:

   Try fitting the model from a random initialization (49 s).

   #+BEGIN_SRC ipython :async t
     import imp; imp.reload(mpebpm.gam_mix)
     torch.manual_seed(0)
     fit = mpebpm.gam_mix.ebpm_gam_mix_em(
       x=temp.X.A,
       s=temp.X.sum(axis=1),
       y=torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float).cuda(),
       k=2,
       num_epochs=400,
       max_em_iters=10,
       log_dir='runs/nbmix/mpebpm-random-init0-iter10')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[53]:
   :END:

   Compute the cross entropy between the estimated \(\hat{z}\) and the ground
   truth.

   #+BEGIN_SRC ipython
     torch.nn.functional.binary_cross_entropy(
       torch.tensor(fit[-1], dtype=torch.float),
       torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[55]:
   : tensor(0.)
   :END:

   Plot the UMAP, colored by the fitted clusters.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/sim-ex-fit.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     plt.gcf().set_size_inches(3, 3)
     for i in range(fit[-1].shape[1]):
       plt.plot(*temp[fit[-1][:,i].astype(bool)].obsm["X_umap"].T, c=cm(i), marker='.', ms=2, lw=0, label=f'Cluster {i}')
     plt.legend(frameon=False, markerscale=4, handletextpad=0)
     plt.xlabel('UMAP 1')
     plt.ylabel('UMAP 2')
     plt.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[56]:
   [[file:figure/nbmix.org/sim-ex-fit.png]]
   :END:

** Amortized inference
   :PROPERTIES:
   :CUSTOM_ID: amortized
   :END:

   Fit the amortized inference model, initializing \(\vmu_k, \vphi_k\) from the
   MLE starting from the ground-truth labels.

   #+BEGIN_SRC ipython
     query = torch.tensor(temp.X.A)
     s = torch.tensor(temp.X.sum(axis=1))
     fit = mpebpm.gam_mix.EBPMGammaMix(
       p=temp.shape[1],
       k=2,
       log_mean=fit0[0],
       log_inv_disp=fit0[1])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[57]:
   :END:

   Look at the initial loss.

   #+BEGIN_SRC ipython
     (
       mpebpm.gam_mix._nb_mix_loss(
         fit.encoder.forward(query),
         query,
         s,
         fit.log_mean,
         fit.log_inv_disp),
       mpebpm.gam_mix._nb_mix_loss(
         torch.tensor(pd.get_dummies(temp.obs['cell_type']).values),
         query,
         s,
         fit.log_mean,
         fit.log_inv_disp)
     )
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[94]:
   #+BEGIN_EXAMPLE
     (tensor(1927253.3750, grad_fn=<NegBackward>),
     tensor(1926631.7500, grad_fn=<NegBackward>))
   #+END_EXAMPLE
   :END:

   Look at the gradients with respect to the encoder network weights.

   #+BEGIN_SRC ipython
     temp_loss = mpebpm.gam_mix._nb_mix_loss(
       fit.encoder.forward(query),
       query,
       torch.tensor(temp.X.sum(axis=1)),
       fit.log_mean,
       fit.log_inv_disp)
     temp_loss.retain_grad()
     temp_loss.backward()
     torch.norm(fit.encoder[0].weight.grad)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[95]:
   : tensor(31154.1895)
   :END:

   Perform amortized inference, initializing \(\vmu_k, \vphi_k\) from the MLE
   starting from the ground-truth labels.

   #+BEGIN_SRC ipython :async t
     torch.manual_seed(1)
     fit1 = mpebpm.gam_mix.EBPMGammaMix(
       p=temp.shape[1],
       k=2,
       log_mean=fit0[0],
       log_inv_disp=fit0[1]).fit(
         x=temp.X.A,
         s=temp.X.sum(axis=1),
         y=pd.get_dummies(temp.obs['cell_type']).values,
         lr=1e-3,
         batch_size=64,
         shuffle=True,
         num_pretrain=80,
         num_epochs=80,
         log_dir='runs/nbmix/ai-inittruth-epoch80')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[62]:
   :END:

   Compute the cross entropy loss over the posterior mean cluster assignments.

   #+BEGIN_SRC ipython
     zhat = fit1.forward(query.cuda()).detach().cpu().numpy()
     torch.nn.functional.binary_cross_entropy(
       torch.tensor(zhat, dtype=torch.float),
       torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[63]:
   : tensor(0.2482)
   :END:

   Plot the approximate posterior over cluster assignments for each point.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/am-inf-ex.png
     cm = plt.get_cmap('Dark2')
     plt.clf()
     fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)
     fig.set_size_inches(4.5, 2.5)
     for i, a in enumerate(ax):
       a.scatter(*temp.obsm["X_umap"].T, s=4, c=np.hstack((np.tile(np.array(cm(i)[:3]), zhat.shape[0]).reshape(-1, 3), zhat[:,i].reshape(-1, 1))))
       a.set_xlabel('UMAP 1')
     ax[0].set_ylabel('UMAP 2')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[82]:
   [[file:figure/nbmix.org/am-inf-ex.png]]
   :END:

   Threshold cluster assignments, and compute the cross entropy loss.

   #+BEGIN_SRC ipython
     zhat_thresh = pd.get_dummies(np.argmax(zhat, axis=1))
     torch.nn.functional.binary_cross_entropy(
       torch.tensor(zhat_thresh.values, dtype=torch.float),
       torch.tensor(pd.get_dummies(temp.obs['cell_type']).values, dtype=torch.float))
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[81]:
   : tensor(0.)
   :END:

   Now, fit the model starting from a random initialization.

   #+BEGIN_SRC ipython :async t
     import imp; imp.reload(mpebpm.gam_mix)
     torch.manual_seed(1)
     fit2 = mpebpm.gam_mix.EBPMGammaMix(
       p=temp.shape[1],
       k=2).fit(
         x=temp.X.A,
         s=temp.X.sum(axis=1),
         y=pd.get_dummies(temp.obs['cell_type']).values,
         lr=1e-2,
         batch_size=64,
         shuffle=True,
         num_pretrain=1,
         num_epochs=120,
         log_dir='runs/nbmix/ai-init1-pretrain1')
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[95]:
   :END:

   Compare the estimated \(\ln\mu\) from the clustering model to the estimates
   using the ground truth labels.

   #+BEGIN_SRC ipython :ipyfile figure/nbmix.org/am-inf-vs-mpebpm.png
     lim = [-10, 10]
     plt.clf()
     fig, ax = plt.subplots(1, 2, sharey=True)
     fig.set_size_inches(4.5, 2.5)
     for i, a in enumerate(ax):
       a.scatter(fit1.log_mean[i].detach().cpu().numpy(), fit2.log_mean[i].detach().cpu().numpy(), s=1, c='k', alpha=0.2)
       a.plot(lim, lim, c='r', lw=1, ls=':')
       a.set_title(f'Cluster {i}')
       a.set_ylim(lim)
       a.set_xlabel('Ground truth initialization')
     ax[0].set_ylabel('Random initialization')
     fig.tight_layout()
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   # Out[84]:
   [[file:figure/nbmix.org/am-inf-vs-mpebpm.png]]
   :END:

* Related work
  :PROPERTIES:
  :CUSTOM_ID: related-work
  :END:

  scVI ([[https://dx.doi.org/10.1038/s41592-018-0229-2][Lopez et al. 2018]],
  [[https://www.biorxiv.org/content/10.1101/532895v2][Xu et al. 2020]])
  implements a related deep unsupervised (more precisely, semi-supervised)
  clustering model ([[https://arxiv.org/abs/1406.5298][Kingma et al. 2014]],
  [[https://arxiv.org/abs/1611.02648][Dilokthanakul et al. 2016]]).

  \begin{align}
    x_{ij} \mid s_i, \lambda_{ij} &\sim \Pois(s_i \lambda_{ij})\\
    \ln s_i &\sim \N(\cdot)\\
    \lambda_{ij} \mid \vz_i &\sim \Gam(\phi_j^{-1}, (\mu_{\lambda}(\vz_i))_j^{-1} \phi_j^{-1})\\
    \vz_i \mid y_i, \vu_i &\sim \N(\mu_z(\vu_i, y_i), \diag(\sigma^2(\vu_i, y_i)))\\
    y_i \mid \vpi &\sim \Mult(1, \vpi)\\
    \vu_i &\sim \N(0, \mi).
  \end{align}

  where

  - \(y_i\) denotes the cluster assignment for cell \(i\)
  - \(\mu_z(\cdot), \sigma^2(\cdot)\) are neural networks mapping the latent
    cluster variable \(y_i\) and Gaussian noise \(\vu_i\) to the latent variable
    \(\vz_i\)
  - \(\mu_{\lambda}(\cdot)\) is a neural network mapping latent variable \(\vz_i\) to
    latent gene expression \(\vlambda_{i}\)

  The intuition behind this model is that, marginalizing over \(y_i\), the
  prior \(p(z_i)\) is a mixture of Gaussians, and therefore the model embeds
  examples in a space which makes clustering easy, and maps examples to those
  clusters simultaneously. To perform variational inference in this model,
  Lopez et al. introduce inference networks

  \begin{align}
    q(\vz_i \mid \vx_i) &= \N(\cdot)\\
    q(y_i \mid \vz_i) &= \Mult(1, \cdot).
  \end{align}

  #+BEGIN_SRC ipython :async t
    import scvi.dataset
    import scvi.inference
    import scvi.models

    expr = scvi.dataset.AnnDatasetFromAnnData(temp)
    m = scvi.models.VAEC(expr.nb_genes, n_batch=0, n_labels=2)
    train = scvi.inference.UnsupervisedTrainer(m, expr, train_size=1, batch_size=32, show_progbar=False, n_epochs_kl_warmup=100)
    train.train(n_epochs=1000, lr=1e-2)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[125]:
  :END:

  # https://scvi.readthedocs.io/en/stable/scvi.models.html#scvi.models.SCANVI
  # https://scvi.readthedocs.io/en/stable/tutorials/scanvi.html?highlight=scanvi#EVF-/-not-EVF

  #+BEGIN_SRC ipython
    post = train.create_posterior(train.model, expr)
    _, _, label = post.get_latent()
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  # Out[118]:
  :END:

  The fundamental difference between scVI and our approach is that scVI
  clusters points in the low-dimensional latent space, and we cluster points in
  the space of latent gene expression (which has equal dimension to the
  observations).

  Rui Shu [[http://ruishu.io/2016/12/25/gmvae/][proposed an alternative
  generative model]], which has some practical benefits and can be adapted to
  this problem

  \begin{align}
    x_{ij} \mid \xiplus, \lambda_{ij} &\sim \Pois(\xiplus \lambda_{ij})\\
    \lambda_{ij} \mid \vz_i &\sim \Gam(\phi_j^{-1}, (\mu_{\lambda}(\vz_i))_j^{-1} \phi_j^{-1})\\
    \vz_i \mid y_i &\sim \N(\mu_z(y_i), \sigma^2(y_i))\\
    y_i \mid \vpi &\sim \Mult(1, \vpi)\\
    q(y_i, \vz_i \mid \vx_i) &= q(y_i \mid \vx_i)\, q(\vz_i \mid y_i, \vx_i).
  \end{align}

  There are additional deep unsupervised learning methods, which could
  potentially be adapted to this setting (reviewed in
  [[https://dx.doi.org/10.1109/ACCESS.2018.2855437][Min et al. 2018]]).
