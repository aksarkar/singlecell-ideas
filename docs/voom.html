<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-06-11 Thu 12:41 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>An improved voom transform for scRNA-seq data</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Abhishek Sarkar">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link href="bootstrap.min.css" rel="stylesheet" />
<link rel="stylesheet" type="text/css" href="htmlize.css"/>
<link rel="stylesheet" type="text/css" href="main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">An improved voom transform for scRNA-seq data</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga658581">Introduction</a></li>
<li><a href="#setup">Setup</a></li>
<li><a href="#org3e4ab9d">Methods</a>
<ul>
<li><a href="#org8a4c1a0">Standard error of point mass expression model</a></li>
<li><a href="#org618f456">Variance of Gamma expression model</a></li>
<li><a href="#orge54949e">Improved limma</a></li>
<li><a href="#orgc7d2b9a">Simulation</a></li>
</ul>
</li>
<li><a href="#org9652fb0">Results</a>
<ul>
<li><a href="#orgbdff6a0">Type 1 error rate</a></li>
<li><a href="#org3ba9df9">Power</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga658581" class="outline-2">
<h2 id="orga658581">Introduction</h2>
<div class="outline-text-2" id="text-orga658581">
<p>
The key idea of limma-voom (Law et al. 2014) is to transform a count matrix
generated by RNA-seq (whether bulk or single cell) into two matrices,
representing the mean and variance of true (log) gene expression. (This
interpretation explains why they did not just use the sampling variance of
the log mean estimate.) These matrices can then be analyzed using
(heteroscedastic) Gaussian methods. However, limma-voom was developed before
the development of scRNA-seq, and therefore before it was possible to measure
the variance of gene expression between cells from a single donor. To address
this limitation, Law et al. instead proposed to pool information across both
donors and genes, estimating a LOESS trend between the mean and variance of
true gene expression values across donors. \(
  \DeclareMathOperator\E{E}
  \DeclareMathOperator\Gam{Gamma}
  \DeclareMathOperator\Poi{Poisson}
  \DeclareMathOperator\V{V}
  \DeclareMathOperator\digamma{\psi}
  \DeclareMathOperator\trigamma{\psi^{(1)}}
  \newcommand\vb{\mathbf{b}}
  \newcommand\vc{\mathbf{c}}
  \newcommand\xiplus{x_{i+}}
  \)
</p>

<p>
Now suppose we have observed scRNA-seq data \(x_{ij}\), where \(x_{ij}\)
denotes the number of molecules from gene \(j\) observed in cell \(i\). Then,
we can estimate a point mass expression model for the cells from each donor
\(k\) (Sarkar and Stephens 2020)
</p>

\begin{align}
  x_{ij} \mid \xiplus, \theta_j &\sim \Poi(\xiplus \exp(\theta_j))\\
  \ell \triangleq \sum_i \ln p(x_{ij} \mid \xiplus, \theta_j) &= \sum_i x_{ij} (\ln \xiplus + \theta_j) - \xiplus \exp(\theta_j) + \mathrm{const}\\
  \frac{\partial \ell}{\partial \theta_j} &= \sum_i x_{ij} - \xiplus \exp(\theta_j)\\
  \theta_j &= \ln\left(\frac{\sum_i x_{ij}}{\sum_i \xiplus}\right)\\
\end{align}

<p>
where \(\xiplus \triangleq \sum_j x_{ij}\). But, this approach is equivalent
to constructing pseudobulk data \(y_{kj} \triangleq \sum_i x_{ij} z_{ik}\),
where \(z_{ik}\) indicates whether cell \(i\) came from donor \(k\), and
using \(\ln(y_{kj} / y_{k+})\) as the estimated mean of true log gene
expression, where \(y_{k+} \triangleq \sum_j y_{kj}\). This simple
theoretical argument and empirical studies have demonstrated that applying
limma-voom to \([y_{kj}]\) is reasonable (Soneson and Robinson 2018, Hsiao
2019). However, the relationship between the voom-estimated variance and the
true gene expression variance is unclear, because the variance used by voom
is between individuals, not within an individual. Further, it is unlikely
that a point mass expression model will be supported by the data.
</p>

<p>
We previously developed a method to efficiently estimate more complex
expression models in large-scale scRNA-seq data sets (Sarkar et
al. 2019). Here, we use that method to investigate two new possibilities for
a precision weight derived from fitted expression models: (1) the inverse
squared standard error of a point mass model, or (2) the inverse variance of
the log true expression under a Gamma model. Specifically, we ask whether
these alterantive approaches improve the power or robustness of DE analysis
in scRNA-seq data.
</p>
</div>
</div>

<div id="outline-container-org3b4cae3" class="outline-2">
<h2 id="setup"><a id="org3b4cae3"></a>Setup</h2>
<div class="outline-text-2" id="text-setup">
<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> anndata
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> mpebpm
<span class="org-keyword">import</span> pandas <span class="org-keyword">as</span> pd
<span class="org-keyword">import</span> scanpy <span class="org-keyword">as</span> sc
<span class="org-keyword">import</span> rpy2.robjects.packages
<span class="org-keyword">import</span> rpy2.robjects.pandas2ri
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> scipy.sparse <span class="org-keyword">as</span> ss
<span class="org-keyword">import</span> scipy.stats <span class="org-keyword">as</span> st
<span class="org-keyword">import</span> sqlite3

rpy2.robjects.pandas2ri.activate()
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
%config <span class="org-variable-name">InlineBackend.figure_formats</span> = <span class="org-builtin">set</span>([<span class="org-string">'retina'</span>])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'figure.facecolor'</span>] = <span class="org-string">'w'</span>
<span class="org-variable-name">plt.rcParams</span>[<span class="org-string">'font.family'</span>] = <span class="org-string">'Nimbus Sans'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e4ab9d" class="outline-2">
<h2 id="org3e4ab9d">Methods</h2>
<div class="outline-text-2" id="text-org3e4ab9d">
</div>
<div id="outline-container-org8a4c1a0" class="outline-3">
<h3 id="org8a4c1a0">Standard error of point mass expression model</h3>
<div class="outline-text-3" id="text-org8a4c1a0">
<p>
The standard error of \(\hat\theta_j\) is analytic
</p>

\begin{align}
  \frac{\partial^2 \ell}{\partial \theta_j^2} &= -\sum_i \xiplus \exp(\theta_j)\\
  \mathcal{I}(\mu_j) &= -\E\left[\frac{\partial^2 \ell}{\partial \mu_j^2}\right] = \sum_i \xiplus \exp(\theta_j)\\
  s_j^2 &= \frac{1}{\sum_i \xiplus \exp(\theta_j)},
\end{align}

<p>
where we have treated \(\xiplus\) as fixed. This treatment is justified by
the fact that the Poisson measurement model for each gene arises from a
Multinomial measurement model for all genes jointly, in which the total
number of molecules observed is fixed rather than a sum of random
variables. As an illustrative example, plot the bootstrap distribution of the
\(\hat\theta_j\) against a normal density with mean \(\theta_j\) and variance
\(s_j^2\) for a simple simulation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">rng</span> = np.random.default_rng(1)
<span class="org-variable-name">n_trials</span> = 1000
<span class="org-variable-name">n</span> = 100
<span class="org-variable-name">s</span> = 1e4
<span class="org-variable-name">theta</span> = -10
<span class="org-variable-name">thetahat</span> = []
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_trials):
  <span class="org-variable-name">x</span> = rng.poisson(s * np.exp(theta), size=n)
  thetahat.append(np.log(x.<span class="org-builtin">sum</span>()) - np.log(n) - np.log(s))
<span class="org-variable-name">thetahat</span> = np.array(thetahat)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.hist(thetahat, bins=16, density=<span class="org-constant">True</span>, color=<span class="org-string">'0.7'</span>)
<span class="org-variable-name">grid</span> = np.linspace(thetahat.<span class="org-builtin">min</span>(), thetahat.<span class="org-builtin">max</span>(), 1000)
plt.plot(grid, st.norm(loc=theta, scale=np.sqrt(1 / (np.exp(theta) * n * s))).pdf(grid), lw=1, c=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'Est ln mean gene expression'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/voom.org/analytic-se-log-link.png" alt="analytic-se-log-link.png">
</p>
</div>

<p>
After introducing multiplicative effects \(\vb_j\) for observed technical
covariates \(\vc_i\) into the measurement model
</p>

\begin{equation}
  x_{ij} \mid \xiplus, \vc_i, \vb_j, \theta_j \sim \Poi(\xiplus \exp(\vc_i' \vb_j + \theta_j)),
\end{equation}

<p>
the standard error of \(\hat\theta_j\) also depends on \(\vc_i'\vb_j\). In
contrast, if we assume the identity link
</p>

\begin{align}
  x_{ij} \mid \xiplus, \mu_j &\sim \Poi(\xiplus \mu_j)\\
  \ell \triangleq \sum_i \ln p(x_{ij} \mid \xiplus, \mu_j) &= \sum_i x_{ij} \ln(\xiplus \mu_j) - \xiplus \mu_j + \mathrm{const}\\
  \frac{\partial \ell}{\partial \mu_j} &= \sum_i \frac{x_{ij}}{\mu_j} - \xiplus\\
  \hat\mu_j &= \frac{\sum_i x_{ij}}{\sum_i \xiplus}\\
  \frac{\partial^2 \ell}{\partial \mu_j^2} &= -\sum_i \frac{x_{ij}}{\mu_j^2}\\
  \mathcal{I}(\mu_j) &= -\E\left[\frac{\partial^2 \ell}{\partial \mu_j^2}\right] = \frac{\E[\sum_i x_{ij}]}{\mu_j^2} = \frac{\sum_i \xiplus}{\mu_j}\\
  s_j^2 &= \frac{\mu_j}{\sum_i \xiplus},
\end{align}

<p>
where we have used the fact that \(\sum_i x_{ij} \sim \Poi(\mu_j \sum_i
   \xiplus)\). Surprisingly, \(\ln \hat\mu_j = \hat\theta_j\), the standard
error of \(\hat\mu_j\) increases as \(\mu_j\) increases, and the standard
error does not depend on technical covariates or their effects. As a sanity
check, plot the bootstrap distribution of \(\hat\mu_j\) against a normal
density with mean \(\theta_j\) and variance \(s_j^2\) for a simple
simulation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-variable-name">rng</span> = np.random.default_rng(2)
<span class="org-variable-name">n_trials</span> = 500
<span class="org-variable-name">n</span> = 100
<span class="org-variable-name">s</span> = 1e4
<span class="org-variable-name">log_mu</span> = -10
<span class="org-variable-name">muhat</span> = []
<span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_trials):
  <span class="org-variable-name">x</span> = rng.poisson(s * np.exp(log_mu), size=n)
  muhat.append(x.<span class="org-builtin">sum</span>() / (n * s))
<span class="org-variable-name">muhat</span> = np.array(muhat)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython">plt.clf()
plt.gcf().set_size_inches(2.5, 2.5)
plt.hist(muhat, bins=14, density=<span class="org-constant">True</span>, color=<span class="org-string">'0.7'</span>)
<span class="org-variable-name">grid</span> = np.linspace(muhat.<span class="org-builtin">min</span>(), muhat.<span class="org-builtin">max</span>(), 1000)
plt.plot(grid, st.norm(loc=muhat.mean(), scale=np.sqrt(muhat[0] / (n * s))).pdf(grid), lw=1, c=<span class="org-string">'k'</span>)
plt.xlabel(<span class="org-string">'Est mean gene expression'</span>)
plt.ylabel(<span class="org-string">'Density'</span>)
plt.tight_layout()
</pre>
</div>


<div class="figure">
<p><img src="figure/voom.org/analytic-se-identity-link.png" alt="analytic-se-identity-link.png">
</p>
</div>
</div>
</div>

<div id="outline-container-org618f456" class="outline-3">
<h3 id="org618f456">Variance of Gamma expression model</h3>
<div class="outline-text-3" id="text-org618f456">
<p>
Assuming a Gamma expression model
</p>

\begin{align}
  \lambda_{ij} &\sim \Gam(\phi_j^{-1}, \mu_j^{-1} \phi_j^{-1})\\
  \E[\ln \lambda_{ij}] &= \digamma(\phi_j^{-1}) + \ln(\mu_j \phi_j)\\
  \V[\ln \lambda_{ij}] &= \trigamma(\phi_j^{-1}),
\end{align}

<p>
where the Gamma distribution is parameterized by shape and rate,
\(\digamma(\cdot)\) denotes the digamma function, and \(\trigamma(\cdot)\)
denotes the trigamma function. We previously noted that robustly estimating
\(\phi_j\) is difficult, even from hundreds of cells per condition; despite
this difficulty, our method can still accurately estimate the variance of
true gene expression.
</p>
</div>
</div>

<div id="outline-container-orge54949e" class="outline-3">
<h3 id="orge54949e">Improved limma</h3>
<div class="outline-text-3" id="text-orge54949e">
<p>
Given transformed data and standard errors, DE analysis is performed in two
steps:
</p>

<ol class="org-ol">
<li>Estimate the effect of the covariate of interest by GLS</li>
<li>Estimate moderated test statistics and \(p\)-values by EB treatment of
the standard errors from (1)</li>
</ol>

<p>
<a href="https://arxiv.org/abs/1901.10679">Lu and Stephens 2019</a> describe a more
powerful approach to solve (2).
</p>
</div>
</div>

<div id="outline-container-orgc7d2b9a" class="outline-3">
<h3 id="orgc7d2b9a">Simulation</h3>
<div class="outline-text-3" id="text-orgc7d2b9a">
<p>
Implement a simplified
<a href="https://stephenslab.github.io/dsc-wiki/overview.html">DSC</a>.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span class="org-keyword">def</span> <span class="org-function-name">simulate_null</span>(dat, n_donors=2, n_cells=100, to_dense=<span class="org-constant">False</span>, min_counts=1, seed=0):
  <span class="org-doc">"""Return counts and labels</span>

<span class="org-doc">  counts - matrix [n_donors * n_cells, n_genes]</span>
<span class="org-doc">  labels - CSR matrix [n_donors * n_cells, n_donors]</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">query</span> = sc.pp.subsample(dat, n_obs=n_donors * n_cells, random_state=seed, copy=<span class="org-constant">True</span>)
  sc.pp.filter_genes(query, min_counts=min_counts)
  <span class="org-variable-name">onehot</span> = ss.coo_matrix((np.ones(query.shape[0]), (np.arange(query.shape[0]), np.repeat(np.arange(n_donors), n_cells)))).tocsr()
  <span class="org-keyword">if</span> to_dense:
    <span class="org-keyword">return</span> query.X.A, onehot.A
  <span class="org-keyword">else</span>:
    <span class="org-keyword">return</span> query.X, onehot

<span class="org-keyword">def</span> <span class="org-function-name">estimate_limma_voom</span>(x, onehot):
  <span class="org-doc">"""Return DataFrame of bhat, se"""</span>
  <span class="org-variable-name">limma</span> = rpy2.robjects.packages.importr(<span class="org-string">'limma'</span>)
  <span class="org-comment-delimiter"># </span><span class="org-comment">Important: limma expects genes x samples</span>
  <span class="org-variable-name">y</span> = limma.voom(x.T @ onehot)
  <span class="org-variable-name">fit</span> = limma.lmFit(y, np.hstack([np.arange(2), np.ones(2)]).reshape(2, -1))
  <span class="org-keyword">return</span> fit

<span class="org-keyword">def</span> <span class="org-function-name">fit_wls</span>(x, y, w):
  <span class="org-doc">"""Return DataFrame of bhat, se</span>

<span class="org-doc">  x - array-like (n, 1)</span>
<span class="org-doc">  y - array-like (n, p)</span>
<span class="org-doc">  w - array-like (n, p)</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">result</span> = []
  <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(y.shape[1]):
    <span class="org-variable-name">wx</span> = np.diag(np.sqrt(w[:,j])) @ x
    <span class="org-variable-name">wy</span> = np.diag(np.sqrt(w[:,j])) @ y[:,j]
    <span class="org-variable-name">bhat</span> = np.linalg.pinv(wx) @ wy
    <span class="org-variable-name">se</span> = 1 / (wx.T @ wx)
    result.append((bhat[0], se[0,0]))
  <span class="org-variable-name">result</span> = pd.DataFrame(result, columns=[<span class="org-string">'bhat'</span>, <span class="org-string">'s2'</span>])
  <span class="org-keyword">return</span> result

<span class="org-keyword">def</span> <span class="org-function-name">estimate_wls_point</span>(x, onehot):
  <span class="org-doc">"""Return DataFrame of bhat, se</span>

<span class="org-doc">  Instead of voom, estimate &#952;_j = log &#956;_j under a point mass expression model</span>
<span class="org-doc">  and its sampling variance, and use those as input to WLS.</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">s</span> = x.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>)
  <span class="org-variable-name">log_mean</span> = mpebpm.sgd.ebpm_point(x, s=s, onehot=onehot)
  <span class="org-comment-delimiter"># </span><span class="org-comment">[n_donors, n_genes]</span>
  <span class="org-variable-name">w</span> = np.exp(log_mean) * (onehot.T @ s)
  <span class="org-keyword">return</span> fit_wls(np.hstack([np.arange(2), np.ones(2)]).reshape(2, -1), log_mean, w)

<span class="org-keyword">def</span> <span class="org-function-name">estimate_wls_gamma</span>(x, onehot, lr=1e-2, num_epochs=40, batch_size=64, shuffle=<span class="org-constant">True</span>):
  <span class="org-doc">"""Return DataFrame of bhat, se</span>

<span class="org-doc">  Instead of voom, estimate E[log &#955;_{ij}] and V[log &#955;_{ij}] under a Gamma</span>
<span class="org-doc">  model, and use those as input to WLS.</span>

<span class="org-doc">  """</span>
  <span class="org-variable-name">s</span> = x.<span class="org-builtin">sum</span>(axis=1, keepdims=<span class="org-constant">True</span>)
  <span class="org-variable-name">log_mean</span>, <span class="org-variable-name">log_inv_disp</span> = mpebpm.ebpm_gamma(
    x,
    s=s,
    onehot=onehot,
    lr=lr,
    num_epochs=num_epochs,
    batch_size=batch_size,
    shuffle=shuffle)
  <span class="org-comment-delimiter"># </span><span class="org-comment">[n_donors, n_genes]</span>
  <span class="org-variable-name">m</span> = sp.digamma(np.exp(log_inv_disp)) + log_mean - log_inv_disp
  <span class="org-variable-name">w</span> = 1 / sp.polygamma(1, np.exp(log_inv_disp))
  <span class="org-keyword">return</span> fit_wls(np.hstack([np.arange(2), np.ones(2)]).reshape(2, -1), m, w)

<span class="org-keyword">def</span> <span class="org-function-name">estimate_moderated_t</span>(bhat, s2):
  <span class="org-variable-name">limma</span> = rpy2.packages.importr(<span class="org-string">'limma'</span>)
  <span class="org-keyword">raise</span> <span class="org-type">NotImplementedError</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">return limma.eBayes()</span>

<span class="org-keyword">def</span> <span class="org-function-name">estimate_ebtm</span>(bhat, s2):
  <span class="org-variable-name">ashr</span> = rpy2.packages.importr(<span class="org-string">'ashr'</span>)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9652fb0" class="outline-2">
<h2 id="org9652fb0">Results</h2>
<div class="outline-text-2" id="text-org9652fb0">
</div>
<div id="outline-container-orgbdff6a0" class="outline-3">
<h3 id="orgbdff6a0">Type 1 error rate</h3>
<div class="outline-text-3" id="text-orgbdff6a0">
<p>
To generate null data, randomly sample cells from a homogeneous population,
and randomly assign labels.
</p>
</div>
</div>

<div id="outline-container-org3ba9df9" class="outline-3">
<h3 id="org3ba9df9">Power</h3>
<div class="outline-text-3" id="text-org3ba9df9">
<p>
To generate true positives, randomly sample cells from a homogeneous
population, randomly assign labels, and then use binomial thinning
(Gerard 2019) to introduce effects of a given magnitude.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Abhishek Sarkar</p>
<p class="date">Created: 2020-06-11 Thu 12:41</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
